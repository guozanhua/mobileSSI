<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />

  <link rel="stylesheet" type="text/css" href="template.css" />

   <link href="templates/menu/css/video-js.css" rel="stylesheet" />



<script src="templates/menu/js/jquery.min.js"></script>
<script type='text/javascript' src='templates/menu/js/jquery.cookie.js'></script>
<script type='text/javascript' src='templates/menu/js/jquery.hoverIntent.minified.js'></script>
<script type='text/javascript' src='templates/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

<link href="templates/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
<link href="templates/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
<link href="templates/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
  
<script src="templates/menu/js/MathJax.js"></script>
        
  
  <script src="templates/script.js"></script>
  
    <script src="templates/jquery.sticky-kit.js "></script>
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Johannes Wagner" />
  <meta name="date" content="2016-03-29" />
  <title>SSI Documentation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="templates/template.css" type="text/css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
</head>
<body>

    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">SSI Documentation</span>
        <ul class="nav pull-right doc-info">
                    <li><p class="navbar-text">Johannes Wagner</p></li>
                              <li><p class="navbar-text">03/29/2016</p></li>
                  </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
        <li><a href="#introduction-keyfeatures"><span class="toc-section-number">1.1</span> Key Features</a></li>
        <li><a href="#introduction-overview"><span class="toc-section-number">1.2</span> Overview</a></li>
        <li><a href="#introduction-methodology"><span class="toc-section-number">1.3</span> Methodology</a></li>
        </ul></li>
        <li><a href="#installation"><span class="toc-section-number">2</span> Installation</a></li>
        <li><a href="#basics"><span class="toc-section-number">3</span> Background</a><ul>
        <li><a href="#basics-signals"><span class="toc-section-number">3.1</span> Signals</a><ul>
        <li><a href="#basics-signals-sampling"><span class="toc-section-number">3.1.1</span> Sampling</a></li>
        <li><a href="#basics-signal-representation"><span class="toc-section-number">3.1.2</span> Representation</a></li>
        <li><a href="#basics-signals-streaming"><span class="toc-section-number">3.1.3</span> Streaming</a></li>
        <li><a href="#basics-signals-buffering"><span class="toc-section-number">3.1.4</span> Buffering</a></li>
        </ul></li>
        <li><a href="#basics-pipelines"><span class="toc-section-number">3.2</span> Pipelines</a><ul>
        <li><a href="#basics-pipelines-signalflow"><span class="toc-section-number">3.2.1</span> Signal Flow</a></li>
        <li><a href="#basics-pipelines-components"><span class="toc-section-number">3.2.2</span> Components</a></li>
        <li><a href="#basics-pipelines-synchronization"><span class="toc-section-number">3.2.3</span> Synchronization</a></li>
        <li><a href="#basics-pipelines-events"><span class="toc-section-number">3.2.4</span> Events</a></li>
        </ul></li>
        <li><a href="#basics-patternrecognition"><span class="toc-section-number">3.3</span> Pattern Recognition</a><ul>
        <li><a href="#basics-patternrecognition-featureextraction"><span class="toc-section-number">3.3.1</span> Feature Extraction</a></li>
        <li><a href="#basics-patternrecognition-classification"><span class="toc-section-number">3.3.2</span> Classification</a></li>
        <li><a href="#basics-patternrecognition-fusionlevels"><span class="toc-section-number">3.3.3</span> Fusion Levels</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#xml"><span class="toc-section-number">4</span> XML</a><ul>
        <li><a href="#xml-basics"><span class="toc-section-number">4.1</span> Basics</a><ul>
        <li><a href="#xml-basics-interpreter"><span class="toc-section-number">4.1.1</span> Run a Pipeline</a></li>
        <li><a href="#xml-basics-component"><span class="toc-section-number">4.1.2</span> Use a Component</a></li>
        <li><a href="#xml-basics-sensor"><span class="toc-section-number">4.1.3</span> Sensor</a></li>
        <li><a href="#xml-basics-consumer"><span class="toc-section-number">4.1.4</span> Consumer</a><ul>
        <li><a href="#xml-basics-consumer-visualization"><span class="toc-section-number">4.1.4.1</span> Visualization</a></li>
        <li><a href="#xml-basics-visualization-storage"><span class="toc-section-number">4.1.4.2</span> Storage</a></li>
        </ul></li>
        <li><a href="#xml-basics-transformer"><span class="toc-section-number">4.1.5</span> Transformer</a><ul>
        <li><a href="#xml-basics-transformer-standard"><span class="toc-section-number">4.1.5.1</span> Standard</a></li>
        <li><a href="#xml-basics-transformer-inplace"><span class="toc-section-number">4.1.5.2</span> In-place</a></li>
        <li><a href="#xml-basics-transformer-chain"><span class="toc-section-number">4.1.5.3</span> Chain</a></li>
        </ul></li>
        <li><a href="#xml-basics-events"><span class="toc-section-number">4.1.6</span> Events</a></li>
        </ul></li>
        <li><a href="#xml-advanced"><span class="toc-section-number">4.2</span> Advanced Concepts</a><ul>
        <li><a href="#xml-advanced-tags-variables"><span class="toc-section-number">4.2.1</span> More Tags</a><ul>
        <li><a href="#xml-advanced-tags-variables"><span class="toc-section-number">4.2.1.1</span> Variables</a></li>
        <li><a href="#xml-advanced-tags-inclusion"><span class="toc-section-number">4.2.1.2</span> Inclusion</a></li>
        <li><a href="#xml-advanced-tags-scripts"><span class="toc-section-number">4.2.1.3</span> Scripts</a></li>
        </ul></li>
        <li><a href="#xml-advanced-network"><span class="toc-section-number">4.2.2</span> Network</a><ul>
        <li><a href="#xml-advanced-network-synchronization"><span class="toc-section-number">4.2.2.1</span> Synchronization</a></li>
        <li><a href="#xml-advanced-network-sharing"><span class="toc-section-number">4.2.2.2</span> Stream and Event Sharing</a></li>
        <li><a href="#xml-advanced-network-xmlsender"><span class="toc-section-number">4.2.2.3</span> XML Sender</a></li>
        </ul></li>
        <li><a href="#xml-advanced-options"><span class="toc-section-number">4.2.3</span> Options</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#python"><span class="toc-section-number">5</span> Python</a><ul>
        <li><a href="#python-components"><span class="toc-section-number">5.1</span> Components</a></li>
        <li><a href="#python-types"><span class="toc-section-number">5.2</span> Types</a></li>
        <li><a href="#python-options"><span class="toc-section-number">5.3</span> Options and Variables</a></li>
        <li><a href="#python-sensor"><span class="toc-section-number">5.4</span> Sensor</a></li>
        <li><a href="#python-consumer"><span class="toc-section-number">5.5</span> Consumer</a></li>
        <li><a href="#python-transformer"><span class="toc-section-number">5.6</span> Transformer</a><ul>
        <li><a href="#python-transformer-filter"><span class="toc-section-number">5.6.1</span> Filter</a></li>
        <li><a href="#python-transformer-feature"><span class="toc-section-number">5.6.2</span> Feature</a></li>
        </ul></li>
        <li><a href="#python-events"><span class="toc-section-number">5.7</span> Events</a></li>
        <li><a href="#image-processing"><span class="toc-section-number">5.8</span> Image Processing</a></li>
        </ul></li>
        <li><a href="#c"><span class="toc-section-number">6</span> C++</a></li>
        </ul>

        </div>
      </div>
            <div class="span9">
            <h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>The <strong>Social Signal Interpretation</strong> (SSI) framework offers tools to record, analyse and recognize human behaviour in real-time, such as gestures, mimics, head nods, and emotional speech. Following a patch-based design pipelines are set up from autonomic components and allow the parallel and synchronized processing of sensor data from multiple input devices. The tutorial at hand explains how to set up processing pipelines in XML/C++ and how to develop new components using C++/Python. For reasons of clarity and comprehensibility code snippets will be used throughout the text. The complete source code samples are available as Visual Studio Solution (see 'openssi\docs\tutorial\tutorial.sln').</p>
<h2 id="introduction-keyfeatures"><span class="header-section-number">1.1</span> Key Features</h2>
<ul>
<li>Synchronized reading from multiple sensor devices</li>
<li>General filter and feature algorithms, such as image processing, signal filtering, frequency analysis and statistical measurements in real-time</li>
<li>Event-based signal processing to combine and interpret high level information, such as gestures, keywords, or emotional user states</li>
<li>Pattern recognition and machine learning tools for on-line and off-line processing, including various algorithms for feature selection, clustering and classification</li>
<li>Patch-based pipeline design (C++-API or XML interface) and a plug-in system to integrate new components (C++ or Python)</li>
</ul>
<h2 id="introduction-overview"><span class="header-section-number">1.2</span> Overview</h2>
<p>A pipeline in SSI starts from one ore more sensor devices, which in real-time provide a stream of samples in form of small data packages. These streams can be on-the-fly manipulated (<em>processing</em>) and mapped onto higher level descriptions (<em>detection</em>). Preliminary predictions can be combined into a final decision (<em>fusion</em>). To learn models from realistic data, SSI includes a logging mechanism that allows to make synchronized recordings of the connected sensor devices. At run-time raw data information can be shared with external applications through the network.</p>
<div class="figure">
<img src="pics/overview.png" alt="Sketch summarizing the various tasks covered by SSI." id="fig:introduction-overview-0" style="width:80.0%" />
<p class="caption"><em>Sketch summarizing the various tasks covered by SSI.</em></p>
</div>
<p>Since social cues are expressed through a variety of channels, such as face, voice, postures, etc., multiple kind of sensors are required to obtain a complete picture of the interaction. In order to combine information generated by different devices raw signal streams need to be synchronized and handled in a coherent way. Therefore an architecture is established to handle diverse signals in a coherent way, no matter if it is a waveform, a heart beat signal, or a video image.</p>
<div class="figure">
<img src="pics/overview-sensors.png" alt="Examples of sensor devices supported by SSI." id="fig:introduction-overview-1" style="width:80.0%" />
<p class="caption"><em>Examples of sensor devices supported by SSI.</em></p>
</div>
<p>Sensor devices deliver raw signals, which need to undergo a number of processing steps in order to carve out relevant information and separate it from noisy or irrelevant parts. Therefore, SSI comes with a large repertoire of filter and feature algorithms to treat audiovisual and physiological signals. By putting processing blocks in series developers can quickly build complex processing pipelines, without having to care much about implementation details such as buffering and synchronization, which will be automatically handled by the framework. Since processing blocks are allocated to separate threads, individual window sizes can be chosen for each processing step.</p>
<div class="figure">
<img src="pics/overview-processing.png" alt="Streams are processed in parallel using tailored window sizes." id="fig:introduction-overview-2" style="width:80.0%" />
<p class="caption"><em>Streams are processed in parallel using tailored window sizes.</em></p>
</div>
<p>Since human communication does not follow the precise mechanisms of a machine, but is tainted with a high amount of variability, uncertainty and ambiguity, robust recognizers have to be built that use probabilistic models to recognize and interpret the observed behaviour. To this end, SSI assembles all tasks of a machine learning pipeline including pre-processing, feature extraction, and online classification/fusion in real-time. Feature extraction converts a signal chunk into a set of compact features – keeping only the essential information necessary to classify the observed behaviour. Classification, finally accomplishes a mapping of observed feature vectors onto a set of discrete states or continuous values. Depending on whether the chunks are reduced to a single feature vector or remain a series of variable length, a statistical or dynamic classification scheme is applied. Examples of both types are included in the SSI framework.</p>
<div class="figure">
<img src="pics/overview-detection.png" alt="Support for statistical and dynamic classification schemes." id="fig:introduction-overview-3" style="width:80.0%" />
<p class="caption"><em>Support for statistical and dynamic classification schemes.</em></p>
</div>
<p>To solve ambiguity in human interaction information extracted from diverse channels need to be combined. In SSI information can be fused at various levels. Already at data level, e. g. when depth information is enhanced with colour information. At feature level, when features of two ore more channels are put together to a single feature vector. Or at decision level, when probabilities of different recognizers are combined. In the latter cases, fused information should represent the same moment in time. If this is not possible due to temporal offsets (e. g. a gesture followed by a verbal instruction) fusion has to take place at event level. The preferred level depends on the type of information that is fused.</p>
<h2 id="introduction-methodology"><span class="header-section-number">1.3</span> Methodology</h2>
<p>To reach a large community, a methodology is followed that addresses developers interested in extending the framework with new functions as well as end-users whose primary objective is to create processing pipelines from what is there. Again, a modular design pays off as it allows components to be classified into few general classes, such as &quot;this-is-a-sensing-component&quot; and &quot;this-is-a-transforming-component&quot;. By masking individual differences behind a few basic entities it becomes possible to translate a pipeline into a another representation (and the other way round). This can be exploited to create an interface which allows end-users to create and edit pipelines outside of an expensive development system and without the knowledge of a complex computer language.</p>
<p>Developers, on the other hand, should be encouraged to enrich the pool of available functions. Therefore an API should be provided which defines basic data types and interfaces as well as tools to test components from an early state of development. In particular, the simulation of sensor input from pre-recorded files becomes an important feature, as it allows for a quick prototyping without setting up a complete recording setup, yet providing realistic conditions, e.g. by ruling out access to future data. Since all data communication is shifted to the framework, additional efforts are minimised.</p>
<div class="figure">
<img src="pics/introduction-methodology.png" alt="General methodology: a simple markup language (A) allows end-users to connect components within a pipeline (B). An interpreter translates the structure, connects the sensor devices and starts the real-time processing (D). Developers are encouraged to implement new components and add them to the pool of available nodes (C)." style="width:80.0%" />
<p class="caption"><em>General methodology: a simple markup language (<strong>A</strong>) allows end-users to connect components within a pipeline (<strong>B</strong>). An interpreter translates the structure, connects the sensor devices and starts the real-time processing (<strong>D</strong>). Developers are encouraged to implement new components and add them to the pool of available nodes (<strong>C</strong>).</em></p>
</div>
<h1 id="installation"><span class="header-section-number">2</span> Installation</h1>
<p>SSI is freely available from <a href="http://openssi.net" class="uri">http://openssi.net</a>. The core of SSI is released under <a href="https://www.gnu.org/licenses/lgpl-3.0.de.html">LGPL</a>. Plugins are either <a href="https://www.gnu.org/licenses/gpl-3.0.de.html">GPL</a> or <a href="https://www.gnu.org/licenses/lgpl-3.0.de.html">LGPL</a>. To check out SSI you need an Apache Subversion (SVN) client (if you're on Windows you can use <a href="https://tortoisesvn.net">TortoiseSVN</a>). See INSTALL file for further installation instructions.</p>
<p>On Windows run <code>setup.exe</code> in the root folder to setup system variables and file associations (for the latter run as administrator) as shown <a href="#fig:introduction-download-0">here</a>. The interface allows you to pick platform and compiler. If you have a 64-bit machine you should always select <code>x64</code> since 32-bit is no longer officially supported (you will have to manually build 32-bit libraries). If you are not planning to develop new components in C++ just keep the default compiler (<code>vc140</code>) and make sure to have <a href="https://www.microsoft.com/de-de/download/details.aspx?id=48145">Visual C++ Redistributable for Visual Studio 2015</a> installed. Otherwise choose the compiler version of your Visual Studio Version (e.g. <code>vc120</code> if you are using Visual Studio 2013).</p>
<blockquote>
<p>CAUTION: If you check out a second version of SSI in another folder on your file system run <code>setup.exe</code> on your current installation and use <code>Undo</code> to remove previous variables and associations before you switch to that version. This will make sure that only one installation of SSI exists in your <code>%PATH%</code> variable (multiple installations in the <code>%PATH%</code> will mess up your installations and possibly cause unexpected behaviour)!</p>
</blockquote>
<div class="figure">
<img src="pics/installation-0.png" alt="Interface to setup system variables and file associations." id="fig:installation-0" style="width:80.0%" />
<p class="caption"><em>Interface to setup system variables and file associations.</em></p>
</div>
<p>If you want to use Python scripts in SSI get the 64-bit version of <a href="https://www.Python.org/downloads/">Python3.5x</a> and install it to <code>C:\%ProgramFiles%\Python35</code> (default installation directory if you check 'install for all users'). We also recommend to install the <a href="http://www.numpy.org/">NumPy</a> package. On Windows you may want to visit this <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/">page</a> by Christoph Gohlke who is providing Windows binaries of many open-source extension packages (make sure to download 64-bit libraries). To install extensions use <code>pip install &lt;path&gt;</code> (you find <code>pip.exe</code> in the <code>Script\</code> folder of your Python installation).</p>
<h1 id="basics"><span class="header-section-number">3</span> Background</h1>
<p>In the following chapter we will deal with the basic concepts of the SSI framework, in particular, the processing, buffering, and synchronisation of signal streams and the various levels at which information can be fused.</p>
<h2 id="basics-signals"><span class="header-section-number">3.1</span> Signals</h2>
<p>Signals are the primary source of information in SSI. Basically, a signal conveys information about some physical quantity over time. By re-measuring the current state in regular intervals and chronically stringing these measurements we obtain a signal. In the following we will refer to a single measurement as a <em>sample</em> and denote a string of samples as a <em>stream</em>. By stepwise modifying a signal, we try to carve out information about a user's social behaviour. This is what social signal processing is about and it is the job of SSI to make it happen.</p>
<h3 id="basics-signals-sampling"><span class="header-section-number">3.1.1</span> Sampling</h3>
<p>Basically, an analog signal is a continuous representation of some quantity varying in time. Since an analog signal has a theoretically infinite resolution it would require infinite space to store it in digital form. Hence, it is necessary to reduce the signal at discrete points of time to discrete quantity levels. To do so an analog signal is observed at fixed time intervals and the current value is quantised to the nearest discrete value of the target resolution. The process is visualised <a href="#fig:basics-signals-sampling-0">here</a>. The graph shows a continuous signal (top) that is reduced to a series of discrete <em>samples</em> (bottom). In a digital world any signal is represented by a finite time-series of discrete samples. Following from the sampling procedure a digital signal is characterised by the frequency at which it is sampled, the so called <em>sampling rate</em>, and the number of bits reserved to encode the samples, the so called <em>sample resolution</em>.</p>
<div class="figure">
<img src="pics/basics-signals-sampling-0.png" alt="Sampling is the process of converting a continuous signal (top) to a time-series of discrete values (bottom). Two properties characterise the process: the frequency at which the signal is sampled (sampling rate) and the number of bits reserved to encode the samples (sample resolution)" id="fig:basics-signals-sampling-0" style="width:80.0%" />
<p class="caption"><em>Sampling is the process of converting a continuous signal (top) to a time-series of discrete values (bottom). Two properties characterise the process: the frequency at which the signal is sampled (sampling rate) and the number of bits reserved to encode the samples (sample resolution)</em></p>
</div>
<p>Both, sampling rate and sample resolution limit the information kept during conversion. For instance, given a resolution of 8 bit we can encode an analog input to one in 256 different levels. If the resolution is good enough to capture sufficient information about the signal, or if we have to enlarge the value range by allocating more bits, depends on the measured quantity. We can check it by determining the quantisation error, which is the difference between an analog value and its quantised value. The useful resolution is limited by the maximum possible <em>signal-to-noise ratio</em> (S/R) that can be achieved for a digitised signal. S/R is a measurement for the level of a desired signal to the level of background noise. If the converter is able to represent signal levels below the background noise additional bits will no longer contribute useful information.</p>
<p>Likewise we can also estimate the sample rate. According to the <em>Nyquist-Shannon sampling theorem</em> a perfect reconstruction of the analog signal is (at least in theory) possible if the sampling rate is more than twice as large as the maximum frequency of the original signal, the so called <em>Nyquist frequency</em>. To understand this relation, we first have to know what is meant by &quot;maximum frequency&quot;. Let us start by defining a periodic signal. A periodic signal is a signal that completes a pattern after a certain amount of time and repeats that pattern over and over again in the same time frame. The length of the time frame in seconds is called <em>period</em> and the completion of a full pattern is called <em>cycle</em>. If the signal is a smooth repetitive oscillation, e.g. a <em>sine wave</em>, we can determine its <em>frequency</em> by counting the number of cycles per seconds. It is measured in units of <em>Hertz</em> (hz = <span class="LaTeX">$\frac{1}{second}$</span>). <a href="#fig:basics-signals-sampling-1">Here</a> we see sine waves with frequencies of 1, 2 and 4 hz. If we sum up the samples of the sine waves along the time axis we get another periodic signal (bottom graph). The maximum frequency of the combined signal is equal to the largest single frequency component, that is 4 hz. In fact, any periodic function can be described as sum of a (possibly infinite) set of sine waves (a so called Fourier series). According to the <em>Nyquist-Shannon sampling theorem</em> we must therefore sample the summed signal at a sample rate greater 8 hz.</p>
<div class="figure">
<img src="pics/basics-signals-sampling-1.png" alt="A periodic signal is a signal that repeats a certain pattern over and over again. The completion of a full pattern is called cycle. By counting the cycles per seconds we can measure the frequency of the signal. The graph shows sine waves with frequencies of 1, 2, and 4 hz (= \frac{1}{second}). The sum of the three sine waves (bottom graph) is again a periodic signal and has a maximum frequency equal to the largest single frequency component, that is 4 hz." id="fig:basics-signals-sampling-1" style="width:80.0%" />
<p class="caption"><em>A periodic signal is a signal that repeats a certain pattern over and over again. The completion of a full pattern is called cycle. By counting the cycles per seconds we can measure the frequency of the signal. The graph shows sine waves with frequencies of 1, 2, and 4 hz (= <span class="LaTeX">$\frac{1}{second}$</span>). The sum of the three sine waves (bottom graph) is again a periodic signal and has a maximum frequency equal to the largest single frequency component, that is 4 hz.</em></p>
</div>
<p>To illustrate the relation between the Nyquist frequency and the sample rate we can think of a periodic signal swinging around the zero axis. If the signal completes on cycle per second, i.e. has a (maximum) frequency of 1 hz, we will observe in every second a peak when signal values are above zero and a valley when signal values are below zero (see <a href="#fig:basics-signals-sampling-1">here</a>). If the signal is sampled at a sampling rate of 1 hz, i.e. we keep only one value per cycle, we pick either always a positive or always negative value. Obviously, we will not be able to correctly reconstruct peaks and valleys. If we increase the sample rate to 2 hz, i.e. we sample twice per second, we have a good chance to get in each cycle a positive and a negative value. However, it may happen that we pick twice in the moment where the signal crosses the zero axis. In this case the sampled signal looks like a zero signal. Only by choosing a sample rate greater 2 hz we can ensure to pick at least one value from a peak and one value from a valley. <a href="#fig:basics-signals-sampling-2">Here</a> we see the summed signal from the previous example sampled at 4 hz, 8 hz and 16 hz. Only in the last case, where the sample rate is above the Nyquist frequency (8 hz), the original signal can be reconstructed.</p>
<div class="figure">
<img src="pics/basics-signals-sampling-2.png" alt="According to the Nyquist-Shannon sampling theorem a signal can be reconstructed if the sampling rate (sr) is more than twice as large as the maximum frequency (Nyquist frequency) of the original signal. The example shows an periodic signal with a maximum frequency of 4 hz sampled at different rates. Only for the last case, where the sample rate is above the Nyquist frequency (8 hz), the original signal can be correctly reconstructed." id="fig:basics-signals-sampling-2" style="width:80.0%" />
<p class="caption"><em>According to the Nyquist-Shannon sampling theorem a signal can be reconstructed if the sampling rate (sr) is more than twice as large as the maximum frequency (Nyquist frequency) of the original signal. The example shows an periodic signal with a maximum frequency of 4 hz sampled at different rates. Only for the last case, where the sample rate is above the Nyquist frequency (8 hz), the original signal can be correctly reconstructed.</em></p>
</div>
<h3 id="basics-signal-representation"><span class="header-section-number">3.1.2</span> Representation</h3>
<p>Signals play a fundamental role in SSI and an elegant way is needed to represent them. Since value type as well as update rate vary depending on the observed quantity, we need a generic solution that is not biased towards a certain type of signals.</p>
<p>For instance, let us consider the properties of a video signal versus that of a sound wave. The images in a video stream are represented as an assembly of several thousand values expressing the colour intensity in a two-dimensional grid. The rate at which images are updated is around 30 times per second. A sound wave, on the other hand, consists of single values quantifying the amplitudes, but is updated several thousand times per second. A tool meant to process video images will therefore differ very much from a tool designed to work with sound waves. To process a video stream we could grab a frame, process it, grab the next frame, process it, and so on. In audio processing such a sequential approach is not applicable because signals values have to be buffered first. And since update rates between values are much shorter and buffering cannot be suspended during processing, the two tasks have to be executed in parallel.</p>
<p>To deal with such differences, raw and processed signals should be represented using a generic data structure that allows handling them independently of origin and content. This can be achieved by splitting signals into smaller parts (<em>windows</em>) and wrap them in uniform packages of one or more values. To account for individual processing timing, packages can be of variable length. Treating signals as sequences of &quot;anonymous&quot; packets has the advantage that any form of buffering and transportation can be implemented independently of the signal source. The same kind of concept can be applied to handle gestures, key words and other higher level information which is not of a continuous nature. A generic wrapper for discrete events makes it possible to implement a central system to collect and distribute events. This allows for an environment that works with virtually any kind of continuous and discrete data produced by sensors and intermediate processing units. A useful basis for a framework intended to process multimodal sensor data.</p>
<div class="figure">
<img src="pics/basics-signal-representation.png" alt="A generic data structure masks signals and events. To account for individual window lengths packages are of variable length." id="fig:basics-signals-representation" style="width:80.0%" />
<p class="caption"><em>A generic data structure masks signals and events. To account for individual window lengths packages are of variable length.</em></p>
</div>
<h3 id="basics-signals-streaming"><span class="header-section-number">3.1.3</span> Streaming</h3>
<p>In SSI, a <em>stream</em> is defined as a snapshot of a signal in memory or on disk, made of a finite number of samples. The samples in a stream are all of the same kind. In the simplest case a sample consists of a single number, which we refer to as a <em>sample value</em>. It can also be an array of numbers and in this case the size of the array defines the <em>dimension</em> of the sample. Instead of numbers the array may also contain more complex data types, e.g. a grouped list of variables. The number of samples in the stream, the sample dimension and the size of a single value in bytes are stored as meta information, together with the sample rate of the signal in hz and a time-stamp, which is the time difference between the beginning of the signal and the first sample in the stream. A stream is represented by a reference to a single memory block which holds the sample values stored in interleaved and chronological order. The total size of the data block is derived as the product of the number of samples <span class="LaTeX">$\times$</span> the sample dimension <span class="LaTeX">$\times$</span> the size of a single value.</p>
<p>Let us consider some <a href="#fig:basics-signals-streaming">examples</a>:</p>
<div class="figure">
<img src="pics/basics-signals-streaming.png" alt="Examples of different quantities and how they are stored in SSI: a cursor signal, an audio chunk, and a video stream." id="fig:basics-signals-streaming" style="width:80.0%" />
<p class="caption"><em>Examples of different quantities and how they are stored in SSI: a cursor signal, an audio chunk, and a video stream.</em></p>
</div>
<p>On the top a stream storing the position of a mouse cursor for 1 s is shown. The sample rate is 5 hz, which means the cursor position is scanned 5 times within one second. Since the position of the mouse cursor is reported in x and y coordinates the stream has two dimensions. To store each coordinate 2 bytes (<em>short integer</em>) are reserved. In total the stream data measures 20 bytes (5 samples <span class="LaTeX">$*$</span> 2 dimensions <span class="LaTeX">$*$</span> 2 bytes). Although a single time-stamp is assigned for the whole stream we can easily give time stamps for each sample by adding the product of sample index and the reciprocal of the sample rate (<span class="LaTeX">$\frac{1}{5Hz} = 0.2$</span> s). For example, the last sample in the stream (index 4) is assigned a time-stamp of 3.8 s (<span class="LaTeX">$3.0 + 4 * 0.2$</span> s). This way of deriving time stamps make it redundant to store time stamps for all except the first sample.</p>
<p>Now, let us think of an audio signal (centre). In due consideration of the Nyquist-Shannon sampling theorem and since the human hearing covers roughly 20 to 20,000 hz, audio is typically sampled at 44,100 hz. The sample resolution is usually 16 bits (2 bytes), which yields a theoretical maximum S/R of 96 db (for each 1-bit increase in bit depth, the S/N increases by approximately 6 db). This is sufficient for typical home loudspeakers with sensitivities of about 85 to 95 db. The audio stream in Figure  stores a mono recording, hence stream dimension is set to 1. If it was stereo dimension would be 2. The sample values are integers within a range of -32,768 to 32,767, which exploits the full resolution of <span class="LaTeX">${2}^{16} = 65,536$</span> digits.</p>
<p>Finally, on bottom a gray scale video stream is given. For demonstration purposes the video images have a resolution of <span class="LaTeX">$4\times3$</span> pixel, i.e. an image consists of 12 gray scale values. It may seem surprising that the stream dimension is still 1 not 12. This becomes clear if we consider a stereo camera which delivers images in pairs. If the dimension would be the sum of pixels from both images we could no longer decide whether it is two images or a single image with twice as many pixels. Hence, to avoid ambiguities we treat each image as a single sample value. Given that the gray scale information of a pixel is encoded with 1 byte the size of a sample value is 12 bytes. Thus, the total size of the video stream is 300 bytes (1 s <span class="LaTeX">$*$</span> 25 hz <span class="LaTeX">$*$</span> 12 bytes). Since a standard webcam delivers images in RGB or YUV (3 bytes per pixel) at a resolution of <span class="LaTeX">$320\times240$</span> pixels up to <span class="LaTeX">$1600\times1200$</span> pixels the space to store of a single sample value can actually take up several <em>MB</em>, e.g. <span class="LaTeX">$1600*1200*3$</span> bytes <span class="LaTeX">$= 5,760,000$</span> bytes <span class="LaTeX">$= 5.76$</span> <em>MB</em>.</p>
<h3 id="basics-signals-buffering"><span class="header-section-number">3.1.4</span> Buffering</h3>
<p>Signal flow describes the path a signal takes from source to output. As described, streams offer a convenient way to implement this flow as they allow handling signals in small portions. If we define a <em>source</em> as an entity which outputs a signal and a <em>sink</em> as an entity which receives it, a natural solution would be to simply pass on the data from source to sinks. However, in this case the intervals at which a sink is served would be steered by the source. This is not feasible, since a sink may prefer a different timing. For example, a source may have a new sample ready every 10 ms, but a sink only asks for input every second. Hence data flow should be delayed until 100 samples have been accumulated. This can be achieved by temporarily storing signal samples in a <em>buffer</em>.</p>
<p>A buffer knows two operations: either samples are written to it, or samples are read from it. It is tied to a particular source and signal, i.e. it stores samples of a certain type, and can connect one ore more sinks (see <a href="#fig:basics-signals-buffering-0">here</a>). Since memory has a finite size, a buffer can only hold a limited number of these samples. When its maximum capacity is reached there are two possibilities to choose from: either enlarge the buffer, which only pushes the problem one stage back, or to sacrifice some samples to make room for new ones. The latter is exactly the function of a so called <em>circular buffer</em> (also <em>ring buffer</em>).</p>
<div class="figure">
<img src="pics/basics-signals-buffering-0.png" alt="Signals are exchanged through buffers which allow sinks* to access the output of a source.*" id="fig:basics-signals-buffering-0" style="width:80.0%" />
<p class="caption"><em>Signals are exchanged through buffers which allow </em>sinks* to access the output of a source.*</p>
</div>
<p>A circular buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. A circular buffer has the advantage that elements need not be shuffled around when elements are added. It starts empty pointing to the first element (<em>head</em>). When new elements are appended the pointer is moved accordingly. Once the end is reached the pointer is again moved to the first position and the buffer begins to overwrite old samples (see <a href="#fig:basics-signals-buffering-1">here</a>). The simple logic of a circulate buffer suites a highly efficient implementation, which is important given the high frequency of read and write operations a buffer possibly has to handle.</p>
<div class="figure">
<img src="pics/basics-signals-buffering-1.png" alt="A circular buffer starts empty pointing to the first element (head). When new elements are appended the pointer is moved accordingly. Once the end is reached the pointer is again moved to the first position and old elements are overwritten." id="fig:basics-signals-buffering-1" style="width:80.0%" />
<p class="caption"><em>A circular buffer starts empty pointing to the first element (head). When new elements are appended the pointer is moved accordingly. Once the end is reached the pointer is again moved to the first position and old elements are overwritten.</em></p>
</div>
<p>When a sink reads from a buffer, it sends a request to receive all samples in a certain time interval. If the data is available a stream including a copy of the samples is returned, i.e. during read operations the content of a buffer is not changed (see Figure (see <a href="#fig:basics-signals-buffering-2">here</a>). Hence, multiple read operations are supported in parallel. During a write operation, on the other hand, a stream with new samples is received by the buffer, which will possibly replace previous samples. Consequently, writing samples to a buffer alters its content and therefore should be handled as an atomic, i.e. exclusive, operation. This is achieved by locking the buffer as long as write operation is in progress, which guarantees that no read operations occur in the meanwhile. (see <a href="#fig:basics-signals-buffering-3">here</a>) we see the content of a buffer before and after a write operation. If we compare the unfolded streams we see that new samples were appended to the front of the stream at cost of samples at the ending.</p>
<div class="figure">
<img src="pics/basics-signals-buffering-2.png" alt="During read operations samples are copied, so that the content of the buffer remains unchanged." id="fig:basics-signals-buffering-2" style="width:80.0%" />
<p class="caption"><em>During read operations samples are copied, so that the content of the buffer remains unchanged.</em></p>
</div>
<div class="figure">
<img src="pics/basics-signals-buffering-3.png" alt="During a write operation samples are appended, which alters the content of the buffer." id="fig:basics-signals-buffering-3" style="width:80.0%" />
<p class="caption"><em>During a write operation samples are appended, which alters the content of the buffer.</em></p>
</div>
<h2 id="basics-pipelines"><span class="header-section-number">3.2</span> Pipelines</h2>
<p>On October 1, 1908, the Ford Motor Company released &quot;Model T&quot;, which is regarded as the first affordable automobile and became the world's most influential car of the 20th century. Although Model T was not the first automobile it was the first affordable car that conquered the mass market. The manufacturing process that made this possible is called an <em>assembly line</em>. In an assembly line interchangeable parts are added as the semi-finished assembly moves from work station to work station where the parts are added in sequence until the final assembly is produced. The huge innovation of this method was that car assembly could be split between several stations, all working simultaneously. Hence, by having <span class="LaTeX">$x$</span> stations, it was possible to operate on a total of <span class="LaTeX">$x$</span> different cars at the same time, each one at a different stage of its assembly.</p>
<p>The same kind of technique is adopted in SSI to achieve an efficient processing of the signals. Work stations are replaced by <em>components</em> which receive and/or output one or more streams, possibly altering the content. By putting multiple components in series, a processing chain is created to transform raw input into something more useful. And like in the case of Henry Ford's assembly lines, the components can work simultaneously. We call such a chain <em>pipeline</em>. Since a pipeline can branch out into multiple forks, but also join forks, it represents a <em>directed acyclic graph</em>.</p>
<h3 id="basics-pipelines-signalflow"><span class="header-section-number">3.2.1</span> Signal Flow</h3>
<p>A pipeline is a chain of processing components, arranged so that the output of each component feeds into successive components connected by a buffer (see <a href="#fig:basics-pipelines-signalflow-0">here</a>). Although such an intermediate step introduces a certain amount of overhead caused by copy operations during read and write operations, it bears several advantages. First of all, the output of a component can be processed in parallel by several independent components and, as already pointed out earlier, read and write operations can be performed asynchronously. To actually make this possible, SSI starts each component as a thread. This is an important feature, since components in front of the the pipeline often work on high update rates of a few milliseconds, whereas components towards the end of a pipeline operate at a scale of seconds. The length at which a signal is processed is also called <em>window</em> length. Generally, we can say that the window length in the pipeline grows with position. Apart from offering more flexibility this also has practical advantages, since components further back in the pipeline cannot cause a delay in the front of the pipeline, which may lead to data loss (Of course, this assumes a proper buffering of intermediate results generated by components from the front until they are ready to be processed by the slower components in at the end). Finally, running components in different threads helps to make the most of multi-core systems.</p>
<div class="figure">
<img src="pics/basics-pipelines-signalflow-0.png" alt="Complex recognitions task are distributed across individual components organised in a directed acyclic graph (A), called pipeline. The output of a component is buffered so that other components can access it at individual window sizes (B)." id="fig:basics-pipelines-signalflow-0" style="width:80.0%" />
<p class="caption"><em>Complex recognitions task are distributed across individual components organised in a directed acyclic graph (A), called pipeline. The output of a component is buffered so that other components can access it at individual window sizes (B).</em></p>
</div>
<p>An efficient handling of the signal flow between the components of a pipeline is one of the challenges to a real-time signal processing framework. The problems to be dealt with are similar to those in a <em>consumer-producer problem</em> (also known as <em>bounded-buffer problem</em>). The problem describes two processes, the <em>producer</em> and the <em>consumer</em>, who share a common, fixed-size buffer. The producer generates data and puts it into the buffer. The consumer consumes data by removing it from the buffer. Hence, the producer must not add data into the buffer if it is full and the consumer must not try to remove data if the buffer is empty. A common solution would be to put the producer to sleep if the buffer is full and wake it up next time the consumer begins to remove data again. Likewise the consumer is put to sleep if it finds the buffer to be empty and awaked when the producer starts to deliver new data. An implementation should avoid situations where both processes are waiting to be awakened to not cause a deadlock. And in case of multiple consumers what is known as starvation, which occurs if a process is perpetually denied data access.</p>
<p>Transferred to the problem at hand there are two differences. First, we can always write to a circular buffers since old values are overwritten when the buffer is full. And second, components do not remove data but get a copy. So except for the beginning a buffer is never empty. However, if a component requests data that have already been overwritten, we still encounter the situation where the requested data cannot be delivered. Either because a component requests samples for a time interval that is not yet fully covered by the buffer. In this case we should put the calling component in a waiting state until the requested data pops up. Or because the requested samples are no longer in the buffer. In this case the operation will never succeed so we should cancel it. As already pointed out earlier write requests should be handled as atomic operations. To prevent starvation, waiting components are put in a queue and awakened in order of arrival.</p>
<p>At run-time components are operated at a <em>best effort delivery</em>, which means data is delivered as soon as it becomes available. When a component receives the requested stream it applies the processing and returns the result. Afterwards it is immediately put on hold for the next data chunk. Ideally, the first component in a pipeline functions as a sort of bottle neck and following components finish in average before the next chunk of samples becomes available. This guaranties that the pipeline will run in real-time. However, since stream data is buffered for a certain amount of time, components are left some margin to finish their task. The window length at which a component operates depends on the algorithm, but also the kind of signal. An audio stream, for instance, which has a high sample rate, is usually processed in chunks of several hundred or even thousand samples. Video streams, on the other hand, are often handled on a frame-by-frame base. While the number of samples in a stream may vary with each call, sample rate and sample dimension must not change. Due to the persistence of streams most resources can be allocated once in the beginning and then be reused until the pipeline is stopped.</p>
<p>A simple example demonstrating the data flow between components of a pipeline is shown <a href="#fig:basics-pipelines-signalflow-1">here</a>.</p>
<div class="figure">
<img src="pics/basics-pipelines-signalflow-1.png" alt="The figure depicts the data flow between two components C1 and C2 connected through a buffer. Samples are represented by dots in varying gray colours. At each step C1 writes two samples to the buffer and C2 sends a request for three samples. Note that although it looks like a synchronous sequence, read and write requests are actually asynchronous operations as C1 and C2 run in different threads. Only for the sake of clearness we will treat them in discrete steps triggered by C1. In the beginning the buffer is empty and both components are in a waiting state. At step I, C1 writes two samples to the buffer. Since C2 requests three samples it is left in waiting state. At step II, C1 appends another two samples summing up to four samples so that C2 receives three of them. At step III, C1 again adds two samples and C2 receives them together with the sample left over from the previous call. At step IV, C2 is again in a waiting state, since only two new samples are available and so on." id="fig:basics-pipelines-signalflow-1" style="width:80.0%" />
<p class="caption"><em>The figure depicts the data flow between two components <strong>C1</strong> and <strong>C2</strong> connected through a buffer. Samples are represented by dots in varying gray colours. At each step <strong>C1</strong> writes two samples to the buffer and <strong>C2</strong> sends a request for three samples. Note that although it looks like a synchronous sequence, read and write requests are actually asynchronous operations as <strong>C1</strong> and <strong>C2</strong> run in different threads. Only for the sake of clearness we will treat them in discrete steps triggered by <strong>C1</strong>. In the beginning the buffer is empty and both components are in a waiting state. At step I, <strong>C1</strong> writes two samples to the buffer. Since <strong>C2</strong> requests three samples it is left in waiting state. At step II, <strong>C1</strong> appends another two samples summing up to four samples so that <strong>C2</strong> receives three of them. At step III, <strong>C1</strong> again adds two samples and <strong>C2</strong> receives them together with the sample left over from the previous call. At step IV, <strong>C2</strong> is again in a waiting state, since only two new samples are available and so on.</em></p>
</div>
<h3 id="basics-pipelines-components"><span class="header-section-number">3.2.2</span> Components</h3>
<p>It is the goal of SSI to let developers quickly build pipelines, but hide as many details about the internal data flow as possible. Components offer this level of abstraction. A developer only indicates the kind of streams to be processed (input and/or output) and proceeds on the assumption that the desired streams will be available at run-time. And when building the pipeline he connects the components as if they directly exchanged data. As shown <a href="#fig:basics-pipelines-components-0">here</a> only the top layer, which defines the connection between the processing components, is visible to the developer, while the bottom layer remains hidden.</p>
<div class="figure">
<img src="pics/basics-pipelines-components-0.png" alt="In SSI only the top layer, which defines the connection between the processing components, is visible to the developer, while the bottom layer remains hidden." id="fig:basics-pipelines-components-0" style="width:80.0%" />
<p class="caption"><em>In SSI only the top layer, which defines the connection between the processing components, is visible to the developer, while the bottom layer remains hidden.</em></p>
</div>
<p>Pipelines are built up of three basic components denoted as <em>sensor</em>, <em>transformer</em>, and <em>consumer</em>. A sensor can be the source of one or more streams, each provided through a separate <em>channel</em>. Most webcams, for instance, also include an in-built microphone to capture sound. In this case, the audio stream will be provided as a second channel in addition to the video channel. A consumer is the counterpart of a sensor. It has one or more input streams, but no output. Transformers are placed in between. They have one ore more input streams and a single output stream. By connecting components in series we can build a pipeline like the one <a href="#fig:basics-pipelines-components-1">here</a>.</p>
<div class="figure">
<img src="pics/basics-pipelines-components-1.png" alt="Pipelines are built up of three basic components denoted as sensor, transformer, and consumer. A sensor is the source of one or more streams. A transformer receives streams, manipulates them and forwards the result in a single stream. A consumer reads one or more streams, but has no output. By connecting components in series we can build a pipeline like the one in the lower part of the figure. It begins with three streams (1), which are processed along different branches (2), and finally combined by a single component (3)." id="fig:basics-pipelines-components-1" style="width:80.0%" />
<p class="caption"><em>Pipelines are built up of three basic components denoted as <strong>sensor</strong>, <strong>transformer</strong>, and <strong>consumer</strong>. A sensor is the source of one or more streams. A transformer receives streams, manipulates them and forwards the result in a single stream. A consumer reads one or more streams, but has no output. By connecting components in series we can build a pipeline like the one in the lower part of the figure. It begins with three streams (1), which are processed along different branches (2), and finally combined by a single component (3).</em></p>
</div>
<p>A transformer may change the sample rate of an input stream (usually making it smaller by reducing the number of samples in the output stream). For the special case that in each window the input stream is reduced to a single sample we call the transformer a <em>feature</em>. And for the special case that the sample rate remains unchanged we call it a <em>filter</em>. The difference is depicted in the <a href="#fig:basics-pipelines-components-2">following</a> figure. Of course, filter and feature may change the number of dimensions just like a regular transformer.</p>
<div class="figure">
<img src="pics/basics-pipelines-components-2.png" alt="A: the input stream is reduced by a factor of three, i.e. the sample rate of the new stream is one third of the sample rate of the input stream. B (feature): in each window the input stream is reduced to a single sample, i.e. the sample rate of the ouput stream is one divided by the window length. C (filter): the number of samples remains unchanged, i.e. the sample rate of the output stream is the same as the sample rate of the input stream." id="fig:basics-pipelines-components-2" style="width:80.0%" />
<p class="caption"><em><strong>A</strong>: the input stream is reduced by a factor of three, i.e. the sample rate of the new stream is one third of the sample rate of the input stream. <strong>B (feature)</strong>: in each window the input stream is reduced to a single sample, i.e. the sample rate of the ouput stream is one divided by the window length. <strong>C (filter)</strong>: the number of samples remains unchanged, i.e. the sample rate of the output stream is the same as the sample rate of the input stream.</em></p>
</div>
<p>When we move a window over a stream we call it a <em>sliding</em> window. In each step the content of a sliding window is retrieved and processed. Afterwards, the window is usually moved by a certain length, which we call the <em>frame</em> size. Often, the frame size is identical to the window size. However, sometimes an overlap between successive windows is desired and in that case the frame size is smaller than the window size. The gap between the frame and the window size is called <em>delta</em> size. If the delta size is non-zero, the sample rate of a feature component is actually the reciprocal of the frame size and not the window size. The relation is depicted <a href="#fig:basics-pipelines-components-3">here</a>.</p>
<div class="figure">
<img src="pics/basics-pipelines-components-3.png" alt="The window size is composed of the frame size and the delta size (of possibly zero length). Between processing steps the window is moved by the frame size." id="fig:basics-pipelines-components-3" style="width:80.0%" />
<p class="caption"><em>The <strong>window</strong> size is composed of the <strong>frame</strong> size and the <strong>delta</strong> size (of possibly zero length). Between processing steps the window is moved by the frame size.</em></p>
</div>
<h3 id="basics-pipelines-synchronization"><span class="header-section-number">3.2.3</span> Synchronization</h3>
<p>A system is <em>time synchronous</em> or <em>in sync</em> if all parts of the system are operating in synchrony. Transferred to a pipeline it means we have to be able to specify the temporal relation between samples in different branches, even if they originate from individual sensor devices. Only then it becomes possible to make proper multimodal recordings and to combine signals of different sources. To keep streams in sync, SSI uses a two-fold strategy: First, it is ensured that the involved sensors start streaming at the same time. Second, in regular intervals it is checked that the number of actually retrieved samples matches the number of expected samples (according to the sample rate).</p>
<p>To achieve the first, SSI hast to make sure all sensor devices are properly connected and a stable data stream has been established. Yet, samples are not pushed into the pipeline until a signal is given to start the pipeline. Only then, buffers get filled. Theoretically, this should guarantee that streams are in sync. Practically, there can still be an offset due to different latencies that it takes for the sensors to capture, convert and deliver the measured values to the computer. However, it is hardly possible to compensate for those differences without using special hardware. Given that these latencies should be rather small (&lt; 1 ms), it is reasonable to ignore them.</p>
<p>Actually, if sensors would now stick precisely to their sample rate, no further treatments were necessary. However, fact is that hardware clocks are imperfect and hence we have to reckon that the specified sample rates are not kept. Hence, the internal timer of a buffer, which is updated according to an &quot;idealised&quot; sample rate, will suffer from a constant time drift. To see why, let us assume a sensor that is supposed to have a sample rate of 100 hz, but in fact provides 101 samples every second. During the first 100 s we will receive 10100 samples, which results in a drift of 1 s. And after one hour we will already encounter an offset of more than half a minute. Matching the recording with another signal captured in parallel is no longer possible unless we are able to measure the drift and subtract it out which is impossible if it is non-linear.</p>
<p>Obviously, such inaccuracies will propagate through the pipeline and cause a time drift between branches originated by different sources. The pipeline will be out of sync. To solve this issue we can compare the buffer clock with a global time measure applying a similar strategy that is used in sensor networks. Only, that in our case the propagation time to receive the global time can be neglected since it is directly obtained from the operating system. Let us understand what happens when we adjust the internal clock of a buffer. If the sample rate was lower than expected it means that too few samples were delivered. If we now set the clock of the buffer ahead in time components that are waiting for input will immediately receive the latest sample(s) once again. And this will compensate the loss. Accordingly, if the sample rate was greater than expected it means that we observe a surplus. In this case the buffer is ahead of the system time. If we reset the clock of the buffer, components that are on hold for new input, now will have to wait a little bit longer until the requested samples become available. Practically, this has the effect that a certain number of samples are omitted.</p>
<p>Of course, duplicating and skipping samples changes the propagated streams and may introduce undesired artefacts. However, as long as a sensor works properly we talk about a time drift of few seconds over several hours at the worst. If buffers are regularly synchronised only every now and then a single sample will be duplicated or skipped. Now, what if a sensor stops providing data, e.g. because the connection is lost? In this case updating the buffer clock would cause the latest samples to be sent over and over again. A behaviour which is certainly not desirable. Hence, if for a certain amount of time no samples have been received from a sensor, a buffer will start to fill in default samples, e.g. zero values. Although we still lose stream information at least synchronisation with other signals is kept until the connection to the sensor can be recovered (see <a href="#fig:basics-pipelines-synchronization-0">here</a>).</p>
<div class="figure">
<img src="pics/basics-pipelines-synchronization-0.png" alt="In regular intervals the clock of a buffer is synchronised with a global time-stamp. If the clock of a buffer runs fast, i.e. more samples were received as expected according to the sample rate, samples are removed. Likewise, if the buffer has fallen behind samples at the front are duplicated. In case of a sensor fail the buffer is filled with default samples, e.g. zero values." id="fig:basics-pipelines-synchronization-0" style="width:80.0%" />
<p class="caption"><em>In regular intervals the clock of a buffer is synchronised with a global time-stamp. If the clock of a buffer runs fast, i.e. more samples were received as expected according to the sample rate, samples are removed. Likewise, if the buffer has fallen behind samples at the front are duplicated. In case of a sensor fail the buffer is filled with default samples, e.g. zero values.</em></p>
</div>
<p>So far, we have considered synchronisation at the front of a pipeline. Now let us focus on a transformer, which sits somewhere in between. As long as a transformer receives input at a constant sample rate and outputs at a constant rate this will preserve synchronisation. For example, a transformer that always outputs half as many samples as it received as input, will exactly halve the sample rate. However, it may happen that a transformer works too slow, i.e. is not able to process the incoming stream in real-time. For some while this will be picked up by the buffer it receives the input from. But at some point the requested samples will not be available since the they date too far in the past. Now the pipeline will block. To prevent this situation transformers can work asynchronously. A transformer that runs in asynchronous mode does not directly read and write to a buffer. Instead it receives samples from an internal buffer that is always updated with the latest samples from the regular input buffer. This prevents the transformer to fall behind. A second internal buffer provides samples to the regular output buffer according to the expected sample rate and is updated whenever the transformer is able to produce new samples (see <a href="#fig:basics-pipelines-synchronization-1">here</a>).</p>
<div class="figure">
<img src="pics/basics-pipelines-synchronization-1.png" alt="A transformer that runs in synchronous mode receives samples directly from the input buffer, manipulates them and writes the result to the output buffer. To not fall behind and block the pipeline it supposed to finish operations in real-time. If this cannot be guaranteed it is run asynchronously. In this case two intermediate buffers ensure that samples can be constantly transferred according to the sample rate. Whenever the transformer has successfully processed data from the internal input buffer it updates the values in the internal output buffer." id="fig:basics-pipelines-synchronization-1" style="width:80.0%" />
<p class="caption"><em>A transformer that runs in synchronous mode receives samples directly from the input buffer, manipulates them and writes the result to the output buffer. To not fall behind and block the pipeline it supposed to finish operations in real-time. If this cannot be guaranteed it is run asynchronously. In this case two intermediate buffers ensure that samples can be constantly transferred according to the sample rate. Whenever the transformer has successfully processed data from the internal input buffer it updates the values in the internal output buffer.</em></p>
</div>
<h3 id="basics-pipelines-events"><span class="header-section-number">3.2.4</span> Events</h3>
<p>So far we have exclusively talked about continuous signals. However, at some point in the pipeline it may not be convenient any more to treat information in form of continuous streams. An utterance, for instance, will neither occur at a constant interval, nor have equal length as it depends on the content of the spoken message. The same is true for the duration of a gesture, which depends on the speed at which it is performed or even shorter spans such as fixations and saccades in the gaze. Also changes in the level of a signal, e.g. a raise in pitch or intensity, may occur suddenly and at a irregular time basis. At this point it makes sense to stick to another representation, which we denote as <em>events</em>. An event describes a certain time span, i.e. it has an start and end time, relative to the moment the pipeline was started and in this way are kept in sync with the streams. But in contrast to streams they are not committed to a fixed sample rate, i.e. they do not have to occur at a regular interval. Events may carry meta information, which add further description to the event. For instance, the recognised key word in case of a key word event.</p>
<p>Components can send and receive events, and each event has an <em>event name</em> and a <em>sender name</em> to identify its origin. The two names form the address of the event: <em>event@sender</em>. The event address is used to register for a certain type of events. Addresses of different events can be put in row by comma, e.g. <em>event1,event2@sender1,sender2</em>. Omitting one side of the address will automatically register all matching events, e.g. <em><span class="citation">@sender</span></em> will deliver all events of the specific sender and a component listening to *<span class="citation">@*</span> will receive any event. There can be any kind of meta data associated with an event, e.g. an array of numbers, a string, or more complex data types. Events are organised in a global list and in a regular interval forwarded to registered components. A component will be notified how many new events have been added since the last update, but may also access previous events (see <a href="#fig:basics-pipelines-events-0">here</a>).</p>
<div class="figure">
<img src="pics/basics-pipelines-events-0.png" alt="Components can register for events filtered by address. The component on the right, for instance, only receives events with name E1* that are sent by a sender with name S1.*" id="fig:basics-pipelines-events-0" style="width:80.0%" />
<p class="caption"><em>Components can register for events filtered by address. The component on the right, for instance, only receives events with name </em>E1* that are sent by a sender with name <em>S1</em>.*</p>
</div>
<p>Since a consumer does not output a new stream, events can be used to <em>trigger</em> when data should be consumed. In this case the consumer does not receive continuous input, but is put in waiting state until the next event becomes available. When a new event occurs, it will be provided with the stream that corresponds to the time frame described by the event as depicted <a href="#fig:basics-pipelines-events-1">here</a>. In this way, processing can be triggered by activity, e.g. apply key word spotting only when voice is detected from the audio. Of course, it is also possible to trigger across different modalities. For instance, activate key word spotting only if the user is looking at certain objects as then we expect him to give commands to manipulate the object.</p>
<div class="figure">
<img src="pics/basics-pipelines-events-1.png" alt="Consumer triggered by an event. T=Transformer, C=Consumer" id="fig:basics-pipelines-events-1" style="width:80.0%" />
<p class="caption"><em>Consumer triggered by an event. T=Transformer, C=Consumer</em></p>
</div>
<h2 id="basics-patternrecognition"><span class="header-section-number">3.3</span> Pattern Recognition</h2>
<p>Machine-aided learning offers an alternative to explicitly programmed instructions. It is especially useful to solve tasks where designing and programming explicit, rule-based algorithms is infeasible. Instead of manually tuning the recognition model, appropriate model parameters are automatically derived after having experienced a learning data set. The quality of a model depends on its ability to generalize accurately on new, unseen examples. SSI supports all steps of a learning task, that is feature extraction, feature selection, model training, and model evaluation. Special focus was put to support both, dynamic and static learning schemes as well as various kind of fusion strategies.</p>
<h3 id="basics-patternrecognition-featureextraction"><span class="header-section-number">3.3.1</span> Feature Extraction</h3>
<p>Generally spoken, a <em>feature</em> transforms a signal chunk into a characteristic property. Choosing discriminating and independent features is key to any pattern recognition algorithm being successful in classification. For instance, calculating the energy of an utterance will reduce a series of thousand measurements to a single value. But whereas none of the original sample values is meaningful by itself, the energy allows for a direct interpretation, e.g. a low energy could be an indication of a whispering voice. By this means features help to carve out information relevant to the problem to be investigated, while at the same time the amount of data is considerably reduced. However, usually it is not a single, but a bunch of features that are retrieved, each describing another characteristics of the input signal. It is common practice to represent features by numerical values or strings and group them into <em>feature vectors</em>.</p>
<p>Features that reduce an input sequence to a single value are <em>statistical</em> features or <em>functionals</em>. Typical functionals are mean, standard deviation, minimum, maximum, etc.. But sometimes, the original sequence is also transformed into a new, although shorter sequence. Such features are called <em>short-term</em> features. To extract them a window is moved over the input sequence and a feature vector is extracted at each step. Often, successive windows overlap to a certain degree. In this case, the <em>frame size</em>, also called <em>frame step</em>, defines how much the window will be moved at each step. Often, the extraction of short-term features is only an intermediate stage which leads to another feature extraction stage. The relationship is visualised <a href="#fig:basics-patternrecognition-featureextraction-0">here</a>.</p>
<div class="figure">
<img src="pics/basics-patternrecognition-featureextraction-0.png" alt="Short-term features are extracted over a shifted window of fixed length. The obtained time-series of feature vectors may serve as input for following feature extraction steps. If at later stages features are computed for long windows of several seconds we denote them as long-term features." id="fig:basics-patternrecognition-featureextraction-0" style="width:80.0%" />
<p class="caption"><em>Short-term features are extracted over a shifted window of fixed length. The obtained time-series of feature vectors may serve as input for following feature extraction steps. If at later stages features are computed for long windows of several seconds we denote them as long-term features.</em></p>
</div>
<p>A &quot;good&quot; feature encodes information that is relevant to the classification task at hand. In other words, there is a sort of correlation between distribution of feature values and the target classes, which allows reasoning the class from the feature. <a href="#fig:basics-patternrecognition-featureextraction-1">Here</a> we see the pitch contour of three utterances articulated with either a happy or a sad voice. Although the semantic content of the sentences is the same their pitch contour is different (&quot;Das will sie am Mittwoch abgeben&quot; (&quot;She will hand it in on Wednesday&quot;), taken from <a href="http://www.expressive-speech.net/">&quot;Berlin Database of Emotional Speech&quot;</a>). This also applies for examples belonging to the same class, which makes it difficult to compare the sentences. By taking the average of the contours local changes are discarded and it becomes more obvious which utterances draw from the same class.</p>
<div class="figure">
<img src="pics/basics-patternrecognition-featureextraction-1.png" alt="Although the wording is the same for the three sentences, they differ in their pitch contour. If articulated with a happy voice (top graph), there are more variations in the pitch contour and in average pitch values are higher compared to sentences pronounced with a sad voice. But even if emotional expression match, there are variations in the pitch contour due a different speaking timing (compare the two bottom graphs). By taking the average of the contours (dotted line) local changes are discarded and their relationship becomes more obvious." id="fig:basics-patternrecognition-featureextraction-1" style="width:80.0%" />
<p class="caption"><em>Although the wording is the same for the three sentences, they differ in their pitch contour. If articulated with a happy voice (top graph), there are more variations in the pitch contour and in average pitch values are higher compared to sentences pronounced with a sad voice. But even if emotional expression match, there are variations in the pitch contour due a different speaking timing (compare the two bottom graphs). By taking the average of the contours (dotted line) local changes are discarded and their relationship becomes more obvious.</em></p>
</div>
<h3 id="basics-patternrecognition-classification"><span class="header-section-number">3.3.2</span> Classification</h3>
<p>Generally, a <em>classifier</em> is a system that maps a vector of feature values onto a single discrete value. In supervised learning the mapping function is inferred from labelled training data. The success of this learning procedure depends on the one hand on the <em>feature representation</em>, i.e. how the input sample is represented, and on the other hand on the <em>learning algorithm</em>. The two entities are closely connected and one cannot succeed without the other. The learning task itself starts from a set of training samples which encode observations whose category membership is known. A training sample connects a measured quantity, usually represented as a sequence of numbers or a string, with a target. Depending on the learning task targets can be represented as discrete class labels or continuous values. The aggregation of training samples is called a dataset. The learning procedure itself works as follows: a set of training samples is presented to the classification model and used to adjust the internal parameters according to the desired target function. Afterwards, the quality of the model is judged by comparing its predictions on previously unseen samples with the correct class labels.</p>
<p><a href="#fig:basics-patternrecognition-classification-0">Here</a> we see an example of a simple facial expression recogniser. A database is created with images showing faces in a <em>happy</em>, <em>neutral</em>, and <em>sad</em> mood. Images are grouped according to their class labels and represented by two features: one value expressing the opening of the mouth and a second value measuring the distance of the mouth corner to the nose tip. Since position and shape of the mouth are altered during the display of facial expressions, we expect variations in the features that are distinctive for the target classes. Identifying possible variations in the training samples and embedding them in a model that generalises to the whole feature space is the crucial task of a classifier. The example shows the position of each sample in the feature space that is spanned by the two features. We can see that samples representing the same class tend to group in certain areas of the feature space. In the concrete case, <em>happy</em> samples - mouth opened and lip corners raised - end up top left, whereas sad samples - mouth closed and lip corners pulled down - are found in the right down. Distance between mouth corner and nose tip turns out to be of similar for <em>neutral</em> and <em>sad</em> samples, so that they are only distinguishable by the opening of the mouth. Based on the distribution of the samples the feature space is now split in such way that samples of the same class preferably belong to the same area. The boundaries between the areas are called decision boundaries.</p>
<div class="figure">
<img src="pics/basics-patternrecognition-classification-0.png" alt="In a facial expression recognition task samples are selected from the area around the mouth in four classes: happy, neutral and sad (left). Each sample is represented by a feature tuple -- opening of the mouth and distance of the mouth corner to the nose tip. Based on the training samples a linear model is learned to separate the feature space according to the three classes (middle). Unknown samples are classified according to their position relative to the decision boundaries in the feature space (right)." id="fig:basics-patternrecognition-classification-0" style="width:80.0%" />
<p class="caption"><em>In a facial expression recognition task samples are selected from the area around the mouth in four classes: <strong>happy</strong>, <strong>neutral</strong> and <strong>sad</strong> (left). Each sample is represented by a feature tuple -- opening of the mouth and distance of the mouth corner to the nose tip. Based on the training samples a linear model is learned to separate the feature space according to the three classes (middle). Unknown samples are classified according to their position relative to the decision boundaries in the feature space (right).</em></p>
</div>
<p>As illustrated <a href="#fig:basics-patternrecognition-classification-1">here</a> a classifier in SSI is a hierarchical construct that combines the decisions of an ensemble of models in a final fusion step. The samples in the training set can stem from multiple sources, whereby each model is assigned to a single source. However, it is well possible to have different models receive input from the same source. Before samples are handed over to a model they may pass one ore more transformations. Also, if only a subset of the features should participate in the classification process an optional selection step can be inserted to choose relevant features. The learning phase starts with training each of the models individually. Afterwards the fusion algorithm is tuned on the probabilities generated by the individual models. The output of the fusion defines the final decision and is output by the classifier.</p>
<div class="figure">
<img src="pics/basics-patternrecognition-classification-1.png" alt="Learning in SSI is organised in a hierarchical structure. Blocks in dashed lines are optional." id="fig:basics-patternrecognition-classification-1" style="width:80.0%" />
<p class="caption"><em>Learning in SSI is organised in a hierarchical structure. Blocks in dashed lines are optional.</em></p>
</div>
<h3 id="basics-patternrecognition-fusionlevels"><span class="header-section-number">3.3.3</span> Fusion Levels</h3>
<p>Combining the predictions of an ensemble of classifiers is one way to fuse information. However, SSI offers several more possibilities. At an early stage two or more streams can be merged into a new stream, which is <em>data level fusion</em>. An example for data fusion is <em>image fusion</em>, which is the process of registering and combining multiple images from single or multiple imaging modalities to improve the imaging quality and reduce randomness and redundancy. Early data fusion in SSI is implemented using a transformer with multiple input streams (see <a href="#fig:basics-patternrecognition-fusion">here</a>).</p>
<p>Combing multimodal information at <em>feature level</em> is another option. It provides more flexibility than data fusion since features offer a higher level of abstraction. In feature level fusion features of all modalities are concatenated to a super vector and presented to a classifier. Usually, classifiers are seated in a consumer and the result of a classification is output as an event. However, if classification is applied on a frame-by-frame basis, it can be replaced by a transformer. In this case, class probabilities are written to a continuous stream. <em>Decision level fusion</em> is similar, but individual features sets are classified first and then class probabilities are combined afterwards. Feature and decision level fusion can be implemented using the techniques described in the previous section.</p>
<p>Finally, information can be combined at <em>event level</em>. In this case the information to be fused has to be attached to the events, e.g. the result of previous classification steps. Fusing at event level has the advantage that modalities can decide individually when to contribute to the fusion process. If no new events are created from a modality it stays neutral.</p>
<div class="figure">
<img src="pics/basics-patternrecognition-fusion.png" alt="Multimodal information can be combined at different stages, ranging from early data fusion to purely event-based fusion, or even a combination of both. T=Transformer, C=Consumer, CL=Classifier" id="fig:basics-patternrecognition-fusion" style="width:80.0%" />
<p class="caption"><em>Multimodal information can be combined at different stages, ranging from early data fusion to purely event-based fusion, or even a combination of both. T=Transformer, C=Consumer, CL=Classifier</em></p>
</div>
<h1 id="xml"><span class="header-section-number">4</span> XML</h1>
<p>In the following we will learn how to build pipelines in XML. XML offers a very simple, yet powerful way to describe the signal flow within a pipeline. At run-time XML pipelines are translated into pre-compiled C++ code and run without loss of performance. However, it is not possible to develop new components in XML.</p>
<h2 id="xml-basics"><span class="header-section-number">4.1</span> Basics</h2>
<p>The following section covers basic concepts by means of an XML pipeline that reads, manipulates, and outputs the position of the mouse cursor.</p>
<h3 id="xml-basics-interpreter"><span class="header-section-number">4.1.1</span> Run a Pipeline</h3>
<p>XML pipelines in SSI are framed by:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;pipeline</span><span class="ot"> ssi-v=</span><span class="st">&quot;1&quot;</span><span class="kw">&gt;</span>
...
<span class="kw">&lt;/pipeline&gt;</span></code></pre></div>
<p>To run a pipeline an interpreter is used that is called <code>xmlpipe</code> (xmlpipe.exe on Windows) and which is located in the <code>bin\</code> folder of SSI followed by two sub-folders that indicate the platform (e.g. <code>x64\</code>) and the compiler version (e.g. <code>vc140\</code>). It is recommended to add this folder to the <code>PATH</code>. On Windows you can use <code>setup.exe</code> in the root folder of SSI, which also allows it to set up other helpful variables and link pipelines to the interpreter (in that case double clicking a pipeline is sufficient to start it). Before we can run a pipeline we save it to a file ending on <code>.pipeline</code>. Now we open the command line and navigate to the directory where we execute the following command:</p>
<pre><code>&gt; xmlpipe -debug &lt;path&gt; &lt;filepath-with-or-without-extension&gt;</code></pre>
<p>By adding the option <code>-debug</code> we can store the console output to a file or stream it to a socket port (if in format <host>:<port>).</p>
<p>When calling a pipeline the working directory is set to the folder where the pipeline is located, i.e. resources used by the pipeline are searched relative to the folder of the pipeline and not the interpreter. Sole exception are plug-ins (see <a href="#xml-basics-component">next</a> Section), which are searched relative to the folder where the interpreter is located.</p>
<blockquote>
<p>Note that <code>xmlpipe</code> does <strong>not</strong> work if the file path contains blanks. As a workaround add <code>xmlpipe</code> to the <code>%PATH%</code> and start the pipeline from the directory where it is located.</p>
</blockquote>
<h3 id="xml-basics-component"><span class="header-section-number">4.1.2</span> Use a Component</h3>
<p>To use a component in an XML pipeline we have to import it from a <em>dynamically-linked library</em> (<em>.dll</em> on Windows or <em>.so</em> on Linux) we call a <em>plug-in</em>. By convention SSI plug-ins have the prefix <code>ssi</code>, which is possibly added. The file extension is optional, too. E.g.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;register&gt;</span>
    <span class="kw">&lt;load</span><span class="ot"> name=</span><span class="st">&quot;mouse&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/register&gt;</span></code></pre></div>
<p>tells SSI to look for a file called <code>ssimouse.dll</code> (or <code>ssimouse.so</code> on Linux) (note that the <code>frame</code> and <code>event</code> plug-in are loaded implicitly). If it is not an absolute path, the file is first searched relative to the folder of the interpreter. If it is not found the directories in the <code>PATH</code> are finally examined. If a file with the name was found the contained components are registered (if a plug-in with that name has already been imported a warning is given). To know which components will be loaded we can browse the <a href="api/index.html">API</a>, e.g.:</p>
<div class="figure">
<img src="pics/xml-basics-components.png" alt="The API of SSI lists components and available options." id="fig:xml-basics-components" style="width:80.0%" />
<p class="caption"><em>The API of SSI lists components and available options.</em></p>
</div>
<p>Here, we see two components (<code>Mouse</code> and <code>CursorMover</code>) with available options. Each option row starts with the name of the option (e.g. <code>sr</code>). We use this name to address the option. It is followed by the type (e.g. <code>DOUBLE</code>) and the number of elements. If the number is 1 a single value is expected (e.g. <code>50.0</code>), otherwise a list of values seperated by <code>,</code> (e.g. <code>1,2,3</code>). Sole exception are strings, which are represented as a list of <code>CHAR</code> values without delimiter (e.g. <code>click@mouse</code>). By default option values must not be changed at run-time, which is indicated by the <code>LOCK</code> field. However, there are exceptions as we will see <a href="#xml-advanced-options">later</a>. The last entry in the row adds a descriptions to the option. There is no limit on the number of options.</p>
<p>We can now create an instance of <code>Mouse</code>, change the sample rate from 50 Hz (default value) to 10 Hz and move the origin of the screen to the bottom left corner:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;Mouse&quot;</span><span class="ot"> sr=</span><span class="st">&quot;10&quot;</span><span class="ot"> flip=</span><span class="st">&quot;false&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>Note that the XML is parsed top-down and the order matters. For instance, you cannot use a component before the according plug-in was loaded. Even if the plug-in will be loaded later on, an error will occur. Same is true for pin connections (see <a href="#xml-basics-sensor">below</a>), which must not be used by a sink before they declared by a source.</p>
<p>We possibly want to create several instances of the same object. To tell them apart SSI automatically assigns an unique id to every instance, which by default is <code>noname</code> followed by a consecutive number (e.g. <code>noname002</code>). We can manually assign a different id by adding <code>:&lt;id&gt;</code> after the componenent name, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;Mouse:mouse&quot;</span><span class="ot"> sr=</span><span class="st">&quot;10&quot;</span><span class="ot"> flip=</span><span class="st">&quot;false&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>If the id is already taken a consecutive number is added to make it unique. Instead of applying options in-place, we can also load them from a file using the reserved attribute <code>option</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;Mouse:mouse&quot;</span><span class="ot"> option=</span><span class="st">&quot;mouse&quot;</span><span class="ot"> sr=</span><span class="st">&quot;10&quot;</span><span class="ot"> flip=</span><span class="st">&quot;false&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>When the previous line is parsed, SSI will first look if a component with an according name has been registered. If this is the case, a new instance with id <code>mouse</code> and default options is created. If the <code>option</code> attribute is set, SSI looks for a file <code>mouse.option</code>. If a relative path is used, the file is searched relative to the folder where the pipeline is located. If the according file is found, options in the file will override the default options (if the according file does not exist, it will be created and filled with default options). However, those values are possibly replaced if options are provided in-place. When the pipeline is closed a snapshot of the current option values is written back to the file (options may change during the execution of the pipeline!). Note that options provided in-place will again override those values at the next start.</p>
<h3 id="xml-basics-sensor"><span class="header-section-number">4.1.3</span> Sensor</h3>
<p>When we look at the <a href="#fig:xml-basics-components">description</a> of the <code>mouse</code> plug-in, in the <code>DETAILS</code> section we see that components are followed by an additional identifier, e.g. <code>SENSOR</code> in case of <code>Mouse</code> or <code>CONSUMER</code> in case of <code>CursorMover</code>. We have already learned about the different roles <a href="#basics-pipelines-components">components</a> can adopt. This basically determines whether a component can be used to produce, manipulate or consume <a href="#basics-signals-streaming">streams</a>. When we add a component to a pipeline we can use certain keywords to apply this role. In case of a sensor we use the keyword <code>sensor</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;sensor</span><span class="ot"> create=</span><span class="st">&quot;Mouse:mouse&quot;</span><span class="ot"> option=</span><span class="st">&quot;mouse&quot;</span><span class="ot"> sr=</span><span class="st">&quot;50.0&quot;</span><span class="ot"> mask=</span><span class="st">&quot;1&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;button&quot;</span><span class="ot"> pin=</span><span class="st">&quot;button&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/sensor&gt;</span></code></pre></div>
<p>A sensor owns one or more channels each providing another quantity. The channels that are available for a sensor are listed after the options in the <a href="#fig:xml-basics-components">description</a> of the component. To establish a connection to a channel we add a tag <code>&lt;output&gt;</code>. It expects two attributes: <code>channel</code>, which is the name of the channel, and <code>pin</code>, which defines a freely selectable identifier used by other components to connect to the stream provided on that channel.</p>
<p>In the example, we connect two channels: The first channel <code>button</code> monitors if certain buttons on the mouse are pressed down (setting <code>mask=1</code> observes the left mouse button). If this is the case, the values in the stream are set to the virtual key code of the pressed buttons and otherwise to 0. The second channel <code>cursor</code> reads the current cursor position on the screen. By default, pixel values are scaled to [0..1] and the origin is set to the bottom left corner of the screen. We manually set the sample rate of the streams to 50 Hz (<code>sr=50.0</code>), i.e. each channel should provide 50 new measurements per second. Note that some sensor work at a fixed sample rate and do not offer an option to change it.</p>
<p>When a connection to a channel is established, a buffer is created to store incoming signal values. The default size of the buffer is 10.0 seconds. It is possible to override the default setting with the attribute <code>size</code>. The unit can be either milliseconds or seconds (adding a trailing <code>ms</code> or <code>s</code>), or samples (plain integer value). E.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;sensor</span><span class="ot"> create=</span><span class="st">&quot;Mouse:mouse&quot;</span><span class="ot"> option=</span><span class="st">&quot;mouse&quot;</span><span class="ot"> mask=</span><span class="st">&quot;1&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;button&quot;</span><span class="ot"> pin=</span><span class="st">&quot;button&quot;</span><span class="ot"> size=</span><span class="st">&quot;5000ms&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> size=</span><span class="st">&quot;250&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/sensor&gt;</span></code></pre></div>
<p>will create for both channels buffers with a capacity of 5 seconds (we have to divide the specified capacity of 250 samples by the sample rate, which is 50 Hz).</p>
<p>Earlier we have discussed the mechanisms used to <a href="#basics-pipelines-synchronization">synchronize</a> streams that are generated by different sources. The basic idea is to check from time to time if the number of retrieved samples fit the expected number of samples (according to the sample rate). If a discrepancy is observed the according stream is adjusted to satisfy the promised number of samples. The default interval between checks is 5.0 seconds. It can be changed by setting the attribute <code>sync</code>. Again, the unit is either milliseconds or seconds (trailing <code>ms</code> or <code>s</code>), or samples (plain integer value).</p>
<p>Likewise, a watch dog is installed on every channel to check in regular intervals if any samples have arrived at all. In this way the failure of a sensor can be detected and SSI starts to send default values on that particular channel (usually zeros). By default the watch dog is set to one second. To change the value the attribute <code>watch</code> is available. Both, <code>sync</code> and <code>watch</code>, may be 0 to turn off the synchronization and/or the watch mechanism. This, of course, may cause in unsynchronized streams. See e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;sensor</span><span class="ot"> create=</span><span class="st">&quot;Mouse:mouse&quot;</span><span class="ot"> option=</span><span class="st">&quot;mouse&quot;</span><span class="ot"> mask=</span><span class="st">&quot;1&quot;</span><span class="kw">&gt;</span>   
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;button&quot;</span><span class="ot"> pin=</span><span class="st">&quot;button&quot;</span><span class="ot"> watch=</span><span class="st">&quot;5.0s&quot;</span><span class="ot"> sync=</span><span class="st">&quot;0&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> watch=</span><span class="st">&quot;0&quot;</span><span class="kw">/&gt;</span>  
<span class="kw">&lt;/sensor&gt;</span></code></pre></div>
<p>Here, we set the watch dog of the first channel to 5 seconds and disable synchronization. For the second channel we turn of the watch dog, but leave synchronization at 5.0 seconds (default value).</p>
<p>As a general thumb rule we usually want to set the synchronization interval greater than the watch dog, but smaller than the buffer size.</p>
<h3 id="xml-basics-consumer"><span class="header-section-number">4.1.4</span> Consumer</h3>
<p>So far, the values read by our sensor are stored in memory. Next, we want to access them.</p>
<h4 id="xml-basics-consumer-visualization"><span class="header-section-number">4.1.4.1</span> Visualization</h4>
<p>The plug-in <code>graphic</code> includes components to visualize streams. So we load it, too:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;register&gt;</span>
    <span class="kw">&lt;load</span><span class="ot"> name=</span><span class="st">&quot;mouse&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;load</span><span class="ot"> name=</span><span class="st">&quot;graphic&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/register&gt;</span></code></pre></div>
<p>In the <a href="api/ssigraphic.html">API</a> we find a component named <code>SignalPainter</code>, which we are going to use. It is marked as a <code>CONSUMER</code> and the tag we use to include it in the pipeline is <code>consumer</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;SignalPainter:plot&quot;</span><span class="ot"> title=</span><span class="st">&quot;BUTTON&quot;</span><span class="ot"> size=</span><span class="st">&quot;10.0&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;button&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span><span class="kw">/&gt;</span>      
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>To connect it to a stream we add the tag <code>&lt;input&gt;</code> and set the attribute <code>pin</code> to the name we have assigned to the button channel (<code>button</code>). The component will now receive the values stored in the buffer that belongs to that channel. However, we have to set an <code>frame</code> size to determine in which interval data is transferred. Again, the unit is either milliseconds or seconds (<code>ms</code> or <code>s</code>), or samples (plain integer value). Which unit we want to choose depends on the situation. If we use (milli)seconds the actual number of samples that is read from the channel depends on the sample rate. If the sample rate is increased, more samples are received and vice versa. Hence, to ensure a fixed number (e.g. if we want to work on every frame of a video stream) we should specify the frame rate in plain samples. In the example, we choose a frame rate of 0.2 seconds, which corresponds to 10 samples (50.0 Hz * 0.2 seconds). To visualize the position of the cursor, too, we only need to append the according pin name (we do the same with the <code>title</code> option to assign each window a different caption):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;SignalPainter:plot&quot;</span><span class="ot"> title=</span><span class="st">&quot;BUTTON;CURSOR&quot;</span><span class="ot"> size=</span><span class="st">&quot;10.0&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;button;pos&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span> <span class="kw">/&gt;</span>     
<span class="kw">&lt;/consumer&gt;</span>     </code></pre></div>
<p>The component will now receive every 0.2 seconds 10 samples from the button stream and 10 samples from the position stream. Note that not every component supports multi-stream input.</p>
<p>By default windows are created in the upper left corner of the screen and will possibly overlap. The <code>Decorator</code> component, which is part of the <code>frame</code> plugin (implicitly loaded), allows it to arrange windows on the screen:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;Decorator&quot;</span><span class="ot"> icon=</span><span class="st">&quot;true&quot;</span><span class="ot"> title=</span><span class="st">&quot;Pipeline&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;area</span><span class="ot"> pos=</span><span class="st">&quot;0,0,400,600&quot;</span><span class="kw">&gt;</span>console<span class="kw">&lt;/area&gt;</span>
    <span class="kw">&lt;area</span><span class="ot"> pos=</span><span class="st">&quot;400,0,400,600&quot;</span><span class="kw">&gt;</span>plot<span class="kw">&lt;/area&gt;</span>
<span class="kw">&lt;/object&gt;</span></code></pre></div>
<p>By adding an <code>area</code> tag, we can specify an area on the screen and instruct the component with the according id (e.g. <code>plot</code>) to move its window(s) into that area. The console window is always assigned the id <code>console</code> and can be moved, too. On Windows we can set <code>icon=true</code> to get an icon in the system tray, which allows it to show/hide all controlled windows. The output of the pipeline is shown <a href="#fig:xml-basics-visualize">here</a>.</p>
<div class="figure">
<img src="pics/xml-basics-visualize.png" alt="Visualization of the button (top) and the cursor (bottom) stream. Dimensions are visualized in separate tracks. Maximum value, current value and minimum value are displayed top-down at the left border of the track. The current time interval in seconds is displayed at the right border." id="fig:xml-basics-visualize" style="width:80.0%" />
<p class="caption"><em>Visualization of the button (top) and the cursor (bottom) stream. Dimensions are visualized in separate tracks. Maximum value, current value and minimum value are displayed top-down at the left border of the track. The current time interval in seconds is displayed at the right border.</em></p>
</div>
<blockquote>
<p>Check out the full <a href="code/xml/basics/consumer_visualization.pipeline">pipeline</a>.</p>
</blockquote>
<h4 id="xml-basics-visualization-storage"><span class="header-section-number">4.1.4.2</span> Storage</h4>
<p>Often we want to store a stream to a file for later analysis. The component <code>FileWriter</code> from the plug-in <code>ioput</code> can do this. Although, it can be connected to a single stream only, we can use several instances to store multiple streams. Each stream will be stored in a separate file. However, SSI's <a href="#basics-pipelines-synchronization">synchronization</a> mechanism still guarantees that the streams are in sync. In the following we will store two versions of the cursor stream (text and binary):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;FileWriter&quot;</span><span class="ot"> path=</span><span class="st">&quot;cursor_t&quot;</span><span class="ot"> type=</span><span class="st">&quot;1&quot;</span><span class="ot"> delim=</span><span class="st">&quot;;&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span>
<span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;FileWriter&quot;</span><span class="ot"> path=</span><span class="st">&quot;cursor_b&quot;</span><span class="ot"> type=</span><span class="st">&quot;0&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span> </code></pre></div>
<p>In fact, when a stream is stored two file will be generated. One file will be named <code>&lt;path&gt;.stream</code> and is used to store meta information about the stream, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; <span class="kw">?&gt;</span>
<span class="kw">&lt;stream</span><span class="ot"> ssi-v=</span><span class="st">&quot;2&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;info</span><span class="ot"> ftype=</span><span class="st">&quot;ASCII&quot;</span><span class="ot"> sr=</span><span class="st">&quot;50.000000&quot;</span><span class="ot"> dim=</span><span class="st">&quot;2&quot;</span><span class="ot"> byte=</span><span class="st">&quot;4&quot;</span><span class="ot"> type=</span><span class="st">&quot;FLOAT&quot;</span><span class="ot"> delim=</span><span class="st">&quot;;&quot;</span><span class="ot"> flags=</span><span class="st">&quot;&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;time</span><span class="ot"> ms=</span><span class="st">&quot;24777115&quot;</span><span class="ot"> local=</span><span class="st">&quot;2016/04/18 16:53:16:444&quot;</span><span class="ot"> system=</span><span class="st">&quot;2016/04/18 14:53:16:444&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;chunk</span><span class="ot"> from=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> to=</span><span class="st">&quot;1.600000&quot;</span><span class="ot"> byte=</span><span class="st">&quot;0&quot;</span><span class="ot"> num=</span><span class="st">&quot;80&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/stream&gt;</span></code></pre></div>
<p>The second file is named <code>&lt;path&gt;.stream~</code> and contains the actual sample data. In case of a text file (<code>format=&quot;1&quot;</code>) a comma-separated values (CSV) file is created. By default, values are separated by space, but another delimiter can be chosen (<code>delim=&quot;;&quot;</code>), e.g.:</p>
<pre><code>0.198437;0.504167
0.295312;0.499167
0.358854;0.507500
0.408854;0.523333
0.420833;0.533333
0.414583;0.555833
0.386979;0.584167
0.280729;0.628333
...</code></pre>
<p>In case of a binary file (<code>format=&quot;0&quot;</code>) raw binary values are stored in interleaved order. Finally, compression can be turned on, too (<code>format=&quot;2&quot;</code>). In that case, the lossless data compression algorithm <a href="https://en.wikipedia.org/wiki/LZ4_%28compression_algorithm%29">LZ4</a> will be used.</p>
<blockquote>
<p>Check out the full <a href="code/xml/basics/consumer_storage.pipeline">pipeline</a>.</p>
</blockquote>
<h3 id="xml-basics-transformer"><span class="header-section-number">4.1.5</span> Transformer</h3>
<p>In an earlier <a href="#basics-pipelines-components">section</a> we have introduced another type of component called <em>transformer</em>. As we will see in the following there are three ways to use a transformer in a pipeline.</p>
<h4 id="xml-basics-transformer-standard"><span class="header-section-number">4.1.5.1</span> Standard</h4>
<p>We have distinguished two special kind of transformer, namely <em>feature</em> (each input window is reduced to a single sample) and <em>filter</em> (sample rate remains unchanged). In the documentation the two special versions of a transformer are marked as <code>FEATURE</code> and <code>FILTER</code>, or <code>TRANSFORMER</code> otherwise. However, in a pipeline we always use the tag <code>transformer</code>, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;transformer</span><span class="ot"> create=</span><span class="st">&quot;DownSample&quot;</span><span class="ot"> keep=</span><span class="st">&quot;3&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> frame=</span><span class="st">&quot;9&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> pin=</span><span class="st">&quot;pos-down&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/transformer&gt;</span></code></pre></div>
<p>keeps every third sample of the input stream and in that way reduces the sample rate of the input stream by one third (16.67 hz).</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;transformer</span><span class="ot"> create=</span><span class="st">&quot;Energy&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.1s&quot;</span><span class="ot"> delta=</span><span class="st">&quot;400ms&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> pin=</span><span class="st">&quot;pos-energy&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/transformer&gt;</span></code></pre></div>
<p>reduces each window to a single value per dimension by taking the energy. Note that the attribute <code>delta</code> is used to extend the window size by 400 milliseconds, i.e. a new sample is generated every 0.1 seconds, but for a window of 0.5 seconds (400 milliseconds overlap with previous window). The sample rate of the output stream is 10 Hz (1/0.1s) and hence depends only on the chosen frame size, but not the sample rate of the input stream.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;transformer</span><span class="ot"> create=</span><span class="st">&quot;MvgAvgVar&quot;</span><span class="ot"> win=</span><span class="st">&quot;5.0&quot;</span><span class="ot"> format=</span><span class="st">&quot;1&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.1s&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> pin=</span><span class="st">&quot;pos-avg&quot;</span><span class="ot"> size=</span><span class="st">&quot;20.0s&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/transformer&gt;</span>  </code></pre></div>
<p>calculates the moving average for a window of 5 seconds (<code>win=&quot;5.0</code>). Since <code>MvgAvgVar</code> is a filter, the output stream has a sample rate that is equal to the input stream (independent of the chosen frame size!). To change the size of the output buffer from 10 seconds (default) to 20 seconds we set the <code>size</code> attribute in the <code>output</code> tag.</p>
<p>To visualize the raw and the processed streams we could again connect a single <code>SignalPainter</code> to the original stream and the three transformed streams. However, we will use a slightly different approach here to highlight another feature of SSI's object naming. Instead of a single instance we create one for each stream we like to visualize. We set the id of the first <code>SignalPainter</code> to <code>plot</code>, all other ids to <code>plot-ex</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;SignalPainter:plot&quot;</span><span class="ot"> title=</span><span class="st">&quot;RAW&quot;</span><span class="ot"> size=</span><span class="st">&quot;10.0&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span> <span class="kw">/&gt;</span>        
<span class="kw">&lt;/consumer&gt;</span>     
<span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;SignalPainter:plot-ex&quot;</span><span class="ot"> title=</span><span class="st">&quot;DOWN&quot;</span><span class="ot"> size=</span><span class="st">&quot;10.0&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos-down&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span> <span class="kw">/&gt;</span>       
<span class="kw">&lt;/consumer&gt;</span>     
<span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;SignalPainter:plot-ex&quot;</span><span class="ot"> title=</span><span class="st">&quot;ENERGY&quot;</span><span class="ot"> size=</span><span class="st">&quot;10.0&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos-energy&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span> <span class="kw">/&gt;</span>     
<span class="kw">&lt;/consumer&gt;</span>     
    <span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;SignalPainter:plot-ex&quot;</span><span class="ot"> title=</span><span class="st">&quot;AVG&quot;</span><span class="ot"> size=</span><span class="st">&quot;10.0&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos-avg&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span> <span class="kw">/&gt;</span>        
<span class="kw">&lt;/consumer&gt;</span>     </code></pre></div>
<p>Since the same id (<code>plot-ex</code>) is now assigned three times a consecutive number is internally added to guarantee unique ids. However, we can still address the three components in once using <code>plot-ex*</code> (or <code>plot*</code> to select all four). That way, we can tell the <code>Decorator</code> to display the windows of multiple components within a single area.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;Decorator&quot;</span><span class="ot"> icon=</span><span class="st">&quot;true&quot;</span><span class="ot"> title=</span><span class="st">&quot;Pipeline&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;area</span><span class="ot"> pos=</span><span class="st">&quot;0,0,400,600&quot;</span><span class="kw">&gt;</span>console<span class="kw">&lt;/area&gt;</span>
    <span class="kw">&lt;area</span><span class="ot"> pos=</span><span class="st">&quot;400,0,400,300&quot;</span><span class="kw">&gt;</span>plot<span class="kw">&lt;/area&gt;</span>
    <span class="kw">&lt;area</span><span class="ot"> pos=</span><span class="st">&quot;400,300,400,300&quot;</span><span class="ot"> nv=</span><span class="st">&quot;1&quot;</span><span class="ot"> nh=</span><span class="st">&quot;3&quot;</span><span class="kw">&gt;</span>plot-ex*<span class="kw">&lt;/area&gt;</span>
<span class="kw">&lt;/object&gt;</span></code></pre></div>
<p>Furthemore, by using the attributes <code>nv</code> and <code>nh</code> we can tell the <code>Decorator</code> how partition an area. In our example we cut the area into 1 x 3 rectangles, which will be filled in top-down manner (actually <code>nv=1</code> had the same effect, since the other parameter is automatically derived from the total number of windows). The result is shown <a href="#fig:xml-basics-transformer">here</a>.</p>
<div class="figure">
<img src="pics/xml-basics-transformer.png" alt="Visualization of the raw cursor (middle) stream and three manipulated versions (right). From the console we can read the properties of the new streams. As expected the new sample rates are 16.67 hz, 10.0 hz, 50.0 hz." id="fig:xml-basics-transformer" style="width:80.0%" />
<p class="caption"><em>Visualization of the raw cursor (middle) stream and three manipulated versions (right). From the console we can read the properties of the new streams. As expected the new sample rates are 16.67 hz, 10.0 hz, 50.0 hz.</em></p>
</div>
<blockquote>
<p>Check out the full <a href="code/xml/basics/transformer.pipeline">pipeline</a>.</p>
</blockquote>
<h4 id="xml-basics-transformer-inplace"><span class="header-section-number">4.1.5.2</span> In-place</h4>
<p>If we manipulate a stream on-the-fly we call it an <em>in-place</em> manipulation. In that case the result of the transformation is not stored in a buffer, but directly handed over to a component. Only consumers and sensors support in-place manipulation, and in the latter case only filter components are allowed. For instance, we can remove the y coordinate from the cursor position by adding a <code>Selector</code> (from the <code>frame</code> plugin-in) to the channel where the cursor stream is created:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;sensor</span><span class="ot"> create=</span><span class="st">&quot;Mouse:mouse&quot;</span><span class="ot"> option=</span><span class="st">&quot;mouse&quot;</span><span class="ot"> sr=</span><span class="st">&quot;50.0&quot;</span><span class="ot"> mask=</span><span class="st">&quot;1&quot;</span><span class="kw">&gt;</span>     
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;transformer</span><span class="ot"> create=</span><span class="st">&quot;Selector&quot;</span><span class="ot"> indices=</span><span class="st">&quot;0&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;/output&gt;</span>
<span class="kw">&lt;/sensor&gt;</span></code></pre></div>
<p>Likewise, we can bind a 'MvgAvgVar' to the input of a <code>SignalPainter</code>, which has the same effect as connecting it to the output pin of a regular transformer. However, other components in the pipeline cannot access the transformed signal any more.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;SignalPainter:plot&quot;</span><span class="ot"> title=</span><span class="st">&quot;AVG&quot;</span><span class="ot"> size=</span><span class="st">&quot;10.0&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;transformer</span><span class="ot"> create=</span><span class="st">&quot;MvgAvgVar&quot;</span><span class="ot"> win=</span><span class="st">&quot;5.0&quot;</span><span class="ot"> format=</span><span class="st">&quot;1&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;/input&gt;</span>        
<span class="kw">&lt;/consumer&gt;</span> </code></pre></div>
<blockquote>
<p>Check out the full <a href="code/xml/basics/transformer_inplace.pipeline">pipeline</a>.</p>
</blockquote>
<h4 id="xml-basics-transformer-chain"><span class="header-section-number">4.1.5.3</span> Chain</h4>
<p>A <code>Chain</code> bundles multiple transformer in a single component. More precisely, an input stream first passes a number of filter steps, which are applied in-series, i.e. the output of the first filter servers as input for the second filter and so on. The output of the last filter operation is then forwarded to each feature component and results are concatenated. Like in the case of <a href="#xml-basics-transformer-inplace">in-place</a> transformations intermediate results are not stored. The filter/feature components are defined in a xml file (ending on <code>.chain</code>) and will be applied in order of occurrence, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;chain&gt;</span>
    <span class="kw">&lt;filter&gt;</span>
        <span class="kw">&lt;item</span><span class="ot"> create=</span><span class="st">&quot;Selector&quot;</span><span class="ot"> indices=</span><span class="st">&quot;0&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;/filter&gt;</span>
    <span class="kw">&lt;feature&gt;</span>       
        <span class="kw">&lt;item</span><span class="ot"> create=</span><span class="st">&quot;Functionals&quot;</span><span class="ot"> names=</span><span class="st">&quot;min,mean,max&quot;</span> <span class="kw">/&gt;</span>
        <span class="kw">&lt;item</span><span class="ot"> create=</span><span class="st">&quot;Energy&quot;</span> <span class="kw">/&gt;</span>
    <span class="kw">&lt;/feature&gt;</span>
<span class="kw">&lt;/chain&gt;</span></code></pre></div>
<p>Here, <code>Selector</code> is used to select the first dimension of the input stream. Afterwards for each frame <code>Functionals</code> extracts the minimum, mean and maximum value and <code>Energy</code> the energy. Yet, we only add a single component to the pipeline:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;transformer</span><span class="ot"> create=</span><span class="st">&quot;Chain&quot;</span><span class="ot"> path=</span><span class="st">&quot;transformer_chain&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span><span class="ot"> delta=</span><span class="st">&quot;0.8s&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> pin=</span><span class="st">&quot;chain&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/transformer&gt;</span>  </code></pre></div>
<blockquote>
<p>Check out the full <a href="code/xml/basics/transformer_chain.pipeline">pipeline</a> and the chain <a href="code/xml/basics/transformer_chain.chain">definition</a>.</p>
</blockquote>
<h3 id="xml-basics-events"><span class="header-section-number">4.1.6</span> Events</h3>
<p>So far we have exclusively worked with streams. Previously, we have introduced <a href="#basics-pipelines-events">events</a> as the counterpart to streams. Unlike streams they represent any sort of information that is not generated in a continuous manner. For instance, we can tell our <code>Mouse</code> component to send an event each time the left mouse button is pressed or released by setting the option <code>event=&quot;true&quot;</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;sensor</span><span class="ot"> create=</span><span class="st">&quot;Mouse:mouse&quot;</span><span class="ot"> sr=</span><span class="st">&quot;50.0&quot;</span><span class="ot"> mask=</span><span class="st">&quot;1&quot;</span><span class="ot"> event=</span><span class="st">&quot;true&quot;</span><span class="ot"> address=</span><span class="st">&quot;click@button&quot;</span><span class="kw">&gt;</span>        
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/sensor&gt;</span></code></pre></div>
<p>We also assign an address to the event, where the first part of the address describes the event and the second part the sender (e.g. <code>click@mouse</code>). Since a consumer (other than a transformer) does not have an output stream, it is possible to trigger it by events, i.e. it will only receive input when an event was fired. To do so, we replace the <code>frame</code> attribute with the <code>address</code> of our event. When an event with a matching address is fired, our <code>SignalPainter</code> will receive a stream, which corresponds to the time slot represented by the event (defined by a start time and a duration in milliseconds):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;SignalPainter:plot&quot;</span><span class="ot"> title=</span><span class="st">&quot;CURSOR&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> address=</span><span class="st">&quot;click@button&quot;</span><span class="ot"> state=</span><span class="st">&quot;completed&quot;</span><span class="kw">/&gt;</span>     
<span class="kw">&lt;/consumer&gt;</span>     </code></pre></div>
<p>Note that we have removed the <code>size</code> option since now we want to display the received stream in its full length. And we set the input attribute <code>state</code> to filter out incomplete events, which is useful because the <code>Mouse</code> component will actually send two different events: one when the button is pressed down for the first time. This event gets a 0 duration and a <code>continued</code> state. And a second event when the button is released again. This event gets a duration equal to the elapsed time since the button was pressed down for the first time and a <code>completed</code> state.</p>
<p>The events sent by the <code>Mouse</code> component are <em>empty events</em>. Except for a state identifier, a start time and a duration (both in milliseconds), empty events do not carry additional information. However, there are other types of events that do so. As the name implies, <em>string events</em> have a (null terminated) string attached. The component <code>StringEventSender</code> creates string events by converting a stream into a string representation:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;StringEventSender&quot;</span><span class="ot"> address=</span><span class="st">&quot;mean@string&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> address=</span><span class="st">&quot;click@mouse&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>If the incoming stream contains more than a single sample, for each dimension the mean value is calculated (unless option <code>mean</code> is set to false) and the values are stringed together. The component <code>TupleEventSender</code> does the same, but without converting the values to a string:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;TupleEventSender&quot;</span><span class="ot"> address=</span><span class="st">&quot;mean@tuple&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> address=</span><span class="st">&quot;click@mouse&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>Finally, the component <code>MapEventSender</code> allows it to assign an identifier to each dimension, i.e. each dimension in the input stream is converted into a key-value pair (here the dimensions of the cursor position are named <code>x</code> and <code>y</code>):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;MapEventSender&quot;</span><span class="ot"> keys=</span><span class="st">&quot;x,y&quot;</span><span class="ot"> address=</span><span class="st">&quot;mean@map&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> address=</span><span class="st">&quot;click@mouse&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>To monitor when events are created, the component <code>EventMonitor</code> displays a list of events within a certain time span. The time span can be given in seconds (trailing <code>s</code>) or milliseconds (integer value or trailing <code>ms</code>):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;EventMonitor:monitor&quot;</span><span class="ot"> title=</span><span class="st">&quot;CURSOR&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;listen</span><span class="ot"> address=</span><span class="st">&quot;@&quot;</span><span class="ot"> span=</span><span class="st">&quot;10.0s&quot;</span> <span class="kw">/&gt;</span>     
<span class="kw">&lt;/object&gt;</span></code></pre></div>
<p>Note that the address is set to <code>mean@</code>, which has the effect that the according component will receive events with name <code>mean</code> independent of the sender. Likewise, it is also possible to receive all events with certain sender names (<code>@&lt;sender1&gt;,&lt;sender2&gt;,...</code>). Of course any combination of event and sender names is possible, too, i.e. <code>&lt;event1&gt;,&lt;event2&gt;,...@&lt;sender1&gt;,&lt;sender2&gt;,...</code>. To receive all events put <code>@</code>. Once more we use the <code>Decorator</code> component to define where the window (with id <code>monitor</code>) will be go on the screen.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;Decorator&quot;</span><span class="ot"> icon=</span><span class="st">&quot;true&quot;</span><span class="ot"> title=</span><span class="st">&quot;Pipeline&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;area</span><span class="ot"> pos=</span><span class="st">&quot;0,0,400,600&quot;</span><span class="kw">&gt;</span>console<span class="kw">&lt;/area&gt;</span>
    <span class="kw">&lt;area</span><span class="ot"> pos=</span><span class="st">&quot;400,0,400,300&quot;</span><span class="kw">&gt;</span>plot<span class="kw">&lt;/area&gt;</span>
    <span class="kw">&lt;area</span><span class="ot"> pos=</span><span class="st">&quot;400,300,400,300&quot;</span><span class="kw">&gt;</span>monitor<span class="kw">&lt;/area&gt;</span>
<span class="kw">&lt;/object&gt;</span></code></pre></div>
<div class="figure">
<img src="pics/xml-basics-events.png" alt="In contrast to the previous examples our SignalPainter is now triggered by an event, i.e. it will only display the cursor position for times when the left mouse button was pressed down. Events are listed in the window below the graph. We see several events with the same information (mean cursor values) in different formats. If an event is incomplete a + is added to the last column." id="fig:xml-basics-events" style="width:80.0%" />
<p class="caption"><em>In contrast to the previous examples our <code>SignalPainter</code> is now triggered by an event, i.e. it will only display the cursor position for times when the left mouse button was pressed down. Events are listed in the window below the graph. We see several events with the same information (mean cursor values) in different formats. If an event is incomplete a <code>+</code> is added to the last column.</em></p>
</div>
<blockquote>
<p>Check out the full <a href="code/xml/basics/events.pipeline">pipeline</a>.</p>
</blockquote>
<h2 id="xml-advanced"><span class="header-section-number">4.2</span> Advanced Concepts</h2>
<p>This chapter covers advanced topics about XML pipelines.</p>
<h3 id="xml-advanced-tags-variables"><span class="header-section-number">4.2.1</span> More Tags</h3>
<p>Some additional tags to make life easier.</p>
<h4 id="xml-advanced-tags-variables"><span class="header-section-number">4.2.1.1</span> Variables</h4>
<p>Sometimes, it is clearer to outsource important options of an XML pipeline to a separate file. In the pipeline we mark those parts with <code>$(&lt;key&gt;)</code>. A configuration file then includes statements of the form <code>&lt;key&gt;</code> = <code>&lt;value&gt;</code>. For instance, we can assign a variable to the sample rate option:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;sensor</span><span class="ot"> create=</span><span class="st">&quot;Mouse&quot;</span><span class="ot"> sr=</span><span class="st">&quot;$(mouse:sr)&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;provider</span><span class="ot"> channel=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/sensor&gt;</span></code></pre></div>
<p>and define the value in a separate file (configuration):</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">mouse</span>:sr = 50.0  <span class="co"># sample rate</span></code></pre></div>
<p>Configuration files have the file ending <code>.pipeline-config</code> and can include an arbitrary number of variables (one per line). A configuration file which has the same name and is in the same folder as a pipeline is a <em>local</em> configuration file and implicitly applied when the according pipeline is started. However, the values defined in a <em>local</em> pipeline are possibly overwritten if one or more <em>global</em> configuration files are passed.</p>
<pre><code>xmlpipe -config global1;global2 my</code></pre>
<p>Here we call a pipeline with name <code>my.pipeline</code>. First, global configuration files will be applied in the order given by the string, i.e. <code>global1.pipeline-config</code> followed by <code>global2.pipeline-config</code>. As soon as a matching key is found its value is applied and can no longer be overwritten by following configuration files. After applying all global configuration files, remaining variables are replaced if a local configuration file (<code>my.pipeline-config</code>) exists. To make sure every key is assigned a value, you would usually want to a local configuration file, which assigns a default value to every variable. Global configuration files, on the other hand, are often used for fine-tuning to choose among different configurations.</p>
<p>To know how the pipeline looks after the configuration files were applied we can call <code>xmlpipe</code> with the option <code>save</code>, which creates a file <code>&lt;path&gt;.pipeline~</code>, e.g.:</p>
<pre><code>xmlpipe -save -config global1;global2 my</code></pre>
<p>For convenience, on Windows the tool <code>xmlpipeui</code> comes with a graphical interface, which lists variables and allows automated parsing of all keys from a pipeline. Via drop-down one can quickly switch between available pipelines/configuration files and run them right off as we see <a href="#fig:xml-advanced-tags-variables">here</a>.</p>
<div class="figure">
<img src="pics/xml-advanced-tags-variables.png" alt="A graphical interface allows it to manage options and run pipelines with different configurations." id="fig:xml-advanced-tags-variables" style="width:80.0%" />
<p class="caption"><em>A graphical interface allows it to manage options and run pipelines with different configurations.</em></p>
</div>
<p>To assign a checkbox or a drop-down menu to a variable one has to add the <code>$(bool)</code> or <code>$(select)</code> keyword in a comment after the key/value pair, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">decorator</span>:icon = true <span class="co"># $(bool) show icon</span>
<span class="kw">mouse</span>:sr = 50.0 <span class="co"># $(select{20.0,50.0,100.0}) sample rate</span></code></pre></div>
<p>By default <code>xmlpipe.exe</code> will be searched in the same folder as the <code>xmlpipeui.exe</code> or if it is not found in the system path (<code>%PATH%</code>). The default path, however, can be changed in the GUI (<code>Pick</code> button) or by creating a file <code>xmlpipeui.ini</code>. The latter also allows it to set alternate search paths for pipeline and configuration files.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">[<span class="kw">exe</span>]
<span class="co"># path to executable</span>
<span class="kw">path</span> = bin\xmlpipe.exe

[<span class="kw">pipe</span>]
<span class="co"># search path for pipelines</span>
<span class="kw">path</span> = .

[<span class="kw">config</span>]
<span class="co"># search path for config files</span>
<span class="kw">path</span> = .</code></pre></div>
<p>Note that The variable <code>$(date)</code> is reserved and will be replaced with a time-stamp in the format <code>yyyy-mm-dd_hh-mm-ss</code> that stores when the pipeline was started.</p>
<blockquote>
<p>Check out the full <a href="code/xml/variables/my.pipeline">pipeline</a> with a corresponding <a href="code/xml/variables/my.pipeline-config">local</a> and <a href="code/xml/variables/global.pipeline-config">global</a> configuration file.</p>
</blockquote>
<h4 id="xml-advanced-tags-inclusion"><span class="header-section-number">4.2.1.2</span> Inclusion</h4>
<p>For the sake of clarity we sometimes want to split a long pipeline in several smaller pipelines. The <code>include</code> element is available for this purpose:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;include</span><span class="ot"> path=</span><span class="st">&quot;</span><span class="er">&lt;</span><span class="st">path-to-another-pipeline&gt;&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>We call a pipeline that is included by another pipeline a <em>child</em> pipeline. A child pipeline has access to all pins the <em>parent </em>pipeline has been created before the inclusion. After the inclusion a parent pipeline has access to all pins defined by the child. This also counts for plug-ins, i.e. a plug-in loaded by the parent is available to the child and if the child pipeline loads a plug-in it is afterwards available to the parent. If a child pipeline is not in the same directory as the parent pipeline the working directory is temporarily moved to the directory of the child pipeline.</p>
<p>Note that global configuration files will be passed from the parent pipeline to the child pipeline. If the parent has a local configuration file, however, it will not apply to its children. Of course, children can have their own local configuration files, which will be applied after all global configuration files have been processed.</p>
<p>Finally, think of the case where we have to alternate pipelines <code>A</code> and <code>B</code> and we either want to include <code>A</code> or <code>B</code>. An elegant way to implement this is by defining a variable <code>$(useA)</code> in combination with two <code>&lt;gate&gt;</code> elements:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;gate</span><span class="ot"> open=</span><span class="st">&quot;$(useA)&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;include</span><span class="ot"> path=</span><span class="st">&quot;A&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/gate&gt;</span> 
<span class="kw">&lt;gate</span><span class="ot"> close=</span><span class="st">&quot;$(useA)&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;include</span><span class="ot"> path=</span><span class="st">&quot;B&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/gate&gt;</span></code></pre></div>
<h4 id="xml-advanced-tags-scripts"><span class="header-section-number">4.2.1.3</span> Scripts</h4>
<p>To run external scripts we use:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;job</span><span class="ot"> path=</span><span class="st">&quot;</span><span class="er">&lt;</span><span class="st">path&gt;&quot;</span><span class="ot"> args=</span><span class="st">&quot;</span><span class="er">&lt;</span><span class="st">args&gt;&quot;</span><span class="ot"> when=</span><span class="st">&quot;</span><span class="er">&lt;</span><span class="st">when&gt;&quot;</span><span class="ot"> wait=</span><span class="st">&quot;</span><span class="er">&lt;</span><span class="st">wait&gt;&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<ul>
<li><code>path</code>: the path to the script.</li>
<li><code>args</code>: a list of optional scripts arguments separated by blanks.</li>
<li><code>when</code>: defines when the script is executed, <code>now</code> will execute the script immediately (default), <code>pre</code> before the pipeline is started and <code>post</code> after the pipeline has been stopped.</li>
<li><code>wait</code>: a value <code>&lt; 0</code> will halt the pipeline until the job is finished (default), otherwise the pipeline will halt for <code>n</code> seconds and continue.</li>
</ul>
<p>Some examples:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;job</span><span class="ot"> path=</span><span class="st">&quot;job.cmd&quot;</span><span class="ot"> args=</span><span class="st">&quot;arg1 arg2&quot;</span><span class="ot"> when=</span><span class="st">&quot;pre&quot;</span><span class="ot"> wait=</span><span class="st">&quot;-1&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>executes script <code>job.cmd</code> with arguments <code>arg1 arg2</code> before the pipeline is started and waits until the job is finished.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;job</span><span class="ot"> path=</span><span class="st">&quot;job.cmd&quot;</span><span class="ot"> args=</span><span class="st">&quot;&quot;</span><span class="ot"> when=</span><span class="st">&quot;post&quot;</span><span class="ot"> wait=</span><span class="st">&quot;-1&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>executes script <code>job.cmd</code> with no arguments after the pipeline was stopped and waits until job is finished.</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;job</span><span class="ot"> path=</span><span class="st">&quot;job.cmd&quot;</span><span class="ot"> args=</span><span class="st">&quot;&quot;</span><span class="ot"> when=</span><span class="st">&quot;now&quot;</span><span class="ot"> wait=</span><span class="st">&quot;2000&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>immediately executes script <code>job.cmd</code> with no arguments and halts pipeline for 2 seconds (afterwards pipeline continues even if the job is not finished yet).</p>
<h3 id="xml-advanced-network"><span class="header-section-number">4.2.2</span> Network</h3>
<p>Complex systems may require it to spread processing on several machines. If the machines are connected in a network it is possible to synchronize their behaviour and even share data between them.</p>
<h4 id="xml-advanced-network-synchronization"><span class="header-section-number">4.2.2.1</span> Synchronization</h4>
<p>To synchronize multiple pipelines one pipeline becomes the server and sends a notification to its clients (all other pipelines).</p>
<p>To turn a pipeline into a server we add the line:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;framework</span><span class="ot"> sync=</span><span class="st">&quot;true&quot;</span><span class="ot"> slisten=</span><span class="st">&quot;false&quot;</span><span class="ot"> sport=</span><span class="st">&quot;1111&quot;</span><span class="ot"> sdialog=</span><span class="st">&quot;true&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>And to set up a client, we add:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;framework</span><span class="ot"> sync=</span><span class="st">&quot;true&quot;</span><span class="ot"> slisten=</span><span class="st">&quot;true&quot;</span><span class="ot"> sport=</span><span class="st">&quot;1111&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>We now start the server and the client pipelines (if <code>sdialog=false</code> we should start the clients first, otherwise the order is not important) and wait until all clients show message:</p>
<pre><code>        waiting for sync message to start</code></pre>
<p>On the server side we should see a dialogue:</p>
<pre><code>[0] QUIT
[1] RUN &amp; QUIT
[2] RUN &amp; RESTART
&gt;</code></pre>
<p>We choose a configuration and press enter. The server now sends a message to the clients and the processing starts simultaneously on all connected machines. If we select <code>0</code> clients will stop immediately. Otherwise processing runs until a stop signal is sent. In case of <code>1</code> pipelines will then quit. Otherwise (if <code>2</code> is selected) client pipelines go back into a waiting state and the server shows the dialogue one again.</p>
<p>To start clients from an external application a string message must be sent to the sync port (default protocol is UDP); a second message stops the pipeline. The format of the message is as follows:</p>
<p><code>SSI:&lt;type&gt;:&lt;id&gt;\0</code></p>
<p>To send a start message replace <code>&lt;type&gt;</code> with <code>STRT</code>. To send a stop message set <code>type</code> to <code>STOP</code>. Valid values for <code>&lt;id&gt;</code> are:</p>
<table>
<colgroup>
<col width="13%" />
<col width="86%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Id</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>QUIT</code></td>
<td align="left">Quits pipeline immediately.</td>
</tr>
<tr class="even">
<td align="left"><code>RUN1</code></td>
<td align="left">Runs the pipeline exactly one time, then quits.</td>
</tr>
<tr class="odd">
<td align="left"><code>RUNN</code></td>
<td align="left">Runs the pipeline and afterwards goes back into waiting state (i.e. waits for another start message).</td>
</tr>
</tbody>
</table>
<p>The following example shows how to start and stop a pipeline with Python:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> socket

UDP_IP <span class="op">=</span> <span class="st">&quot;127.0.0.1&quot;</span>
UDP_PORT <span class="op">=</span> <span class="dv">1111</span>
sock <span class="op">=</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

<span class="bu">input</span>(<span class="st">&quot;</span><span class="ch">\n\t</span><span class="st">press enter to start pipeline</span><span class="ch">\n</span><span class="st">&quot;</span>)

MESSAGE <span class="op">=</span> <span class="st">&quot;SSI:STRT:RUN1\0&quot;</span>
sock.sendto(<span class="bu">bytes</span>(MESSAGE, <span class="st">&quot;utf-8&quot;</span>), (UDP_IP, UDP_PORT))

<span class="bu">input</span>(<span class="st">&quot;</span><span class="ch">\n\t</span><span class="st">press enter to stop pipeline</span><span class="ch">\n</span><span class="st">&quot;</span>)

MESSAGE <span class="op">=</span> <span class="st">&quot;SSI:STOP:RUN1\0&quot;</span>
sock.sendto(<span class="bu">bytes</span>(MESSAGE, <span class="st">&quot;utf-8&quot;</span>), (UDP_IP, UDP_PORT))</code></pre></div>
<h4 id="xml-advanced-network-sharing"><span class="header-section-number">4.2.2.2</span> Stream and Event Sharing</h4>
<p>To share a stream between two pipelines we use <code>StreamWriter</code> and <code>StreamReader</code> (from the <code>ioput</code> plug-in). The sender connects the <code>StreamWriter</code> with the pin of the stream it wants to share and sets a port, as well as the host of the receiving machines:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;SocketWriter&quot;</span><span class="ot"> port=</span><span class="st">&quot;2222&quot;</span><span class="ot"> host=</span><span class="st">&quot;127.0.0.1&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>The receiver adds the <code>StreamReader</code> and listens to port set by the sender. It is also necessary to describe the incoming stream (we have to allocate an appropriate buffer before the actual streaming starts):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;sensor</span><span class="ot"> create=</span><span class="st">&quot;SocketReader&quot;</span><span class="ot"> port=</span><span class="st">&quot;2222&quot;</span><span class="ot"> ssr=</span><span class="st">&quot;50.0&quot;</span><span class="ot"> sdim=</span><span class="st">&quot;2&quot;</span><span class="ot"> sbyte=</span><span class="st">&quot;4&quot;</span><span class="ot"> stype=</span><span class="st">&quot;9&quot;</span><span class="kw">&gt;</span>      
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;socket&quot;</span><span class="ot"> pin=</span><span class="st">&quot;cursor&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/sensor&gt;</span></code></pre></div>
<p>In a similar way we share can events by setting up a sender:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;SocketEventWriter&quot;</span><span class="ot"> port=</span><span class="st">&quot;3333&quot;</span><span class="ot"> osc=</span><span class="st">&quot;true&quot;</span><span class="ot"> host=</span><span class="st">&quot;127.0.0.1&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;listen</span><span class="ot"> address=</span><span class="st">&quot;click@button&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/object&gt;</span>       </code></pre></div>
<p>and a receiver:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;SocketEventReader&quot;</span><span class="ot"> port=</span><span class="st">&quot;3333&quot;</span><span class="ot"> osc=</span><span class="st">&quot;true&quot;</span><span class="ot"> address=</span><span class="st">&quot;event@button&quot;</span><span class="kw">/&gt;</span>  </code></pre></div>
<blockquote>
<p>Check out the <a href="code/xml/network/server.pipeline">server</a> and the <a href="code/xml/network/client.pipeline">client</a>.</p>
</blockquote>
<h4 id="xml-advanced-network-xmlsender"><span class="header-section-number">4.2.2.3</span> XML Sender</h4>
<p>An interesting way of sharing data with external applications allows the component <code>XMLEventSender</code> from the <code>event</code> plug-in. It offers a high level of flexibility as it does not prescribe a fixed format (except for a valid XML structure). Instead it takes a template and fills it at run-time with input from the pipeline.</p>
<p>To access data in the template file we first connect according streams and events to <code>XMLEventSender</code>, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;XMLEventSender:monitor&quot;</span><span class="ot"> path=</span><span class="st">&quot;xmlsender&quot;</span><span class="ot"> address=</span><span class="st">&quot;ssi@xml&quot;</span><span class="ot"> monitor=</span><span class="st">&quot;true&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;cursor;button&quot;</span><span class="ot"> frame=</span><span class="st">&quot;5&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;listen</span><span class="ot"> address=</span><span class="st">&quot;@mouse&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>gives access to two streams (<code>button</code> and <code>cursor</code>) and events with the sender name <code>mouse</code>. The template is defined in a file <code>xmlsender.xml</code>. To address streams and events in the template we use variables in the form <code>$(x)</code> and replace <code>x</code> either with the index of a stream (counting from 0) or an event address (i.e. <code>&lt;name&gt;@&lt;sender&gt;</code>), e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;mouse&gt;</span>    
    <span class="kw">&lt;cursor&gt;</span>$(0)<span class="kw">&lt;/cursor&gt;</span>
    <span class="kw">&lt;button&gt;</span>$(1)<span class="kw">&lt;/button&gt;</span>
    <span class="kw">&lt;event&gt;</span>$(button@mouse)<span class="kw">&lt;/event&gt;</span>
<span class="kw">&lt;/mouse&gt;</span></code></pre></div>
<p>generates the following <a href="#fig:xml-advanced-network-xmlsender-0">output</a>:</p>
<div class="figure">
<img src="pics/xml-advanced-network-xmlsender-0.png" alt="Template filled with input from the pipeline." id="fig:xml-advanced-network-xmlsender-0" style="width:80.0%" />
<p class="caption"><em>Template filled with input from the pipeline.</em></p>
</div>
<p>We see that <code>$(0)</code> and <code>$(1)</code> are replaced with samples of the according streams and <code>$(button@mouse)</code> with an empty string. Since empty events carry no additional information that could be displayed, we insert an additional component that calculates the mean, minimum and maximum value of the cursor position and publishes them as a new event <code>features@mouse</code> (actually a <a href="#xml-basics-events">map event</a>):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;FunctionalsEventSender&quot;</span><span class="ot"> names=</span><span class="st">&quot;mean,min,max&quot;</span><span class="ot"> address=</span><span class="st">&quot;features@mouse&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> address=</span><span class="st">&quot;click@mouse&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>By adding options to the variable (<code>$(x{options}</code>) we can further influence how the inserted information is displayed, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;mouse&gt;</span>    
    <span class="kw">&lt;cursor</span><span class="ot"> x=</span><span class="st">&quot;$(0{select=0;functional=mean})&quot;</span><span class="ot"> y=</span><span class="st">&quot;$(0{select=1;functional=mean})&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;button&gt;</span>$(1{functional=max;precision=0})<span class="kw">&lt;/button&gt;</span>
    <span class="kw">&lt;features&gt;</span>$(features@mouse)<span class="kw">&lt;/features&gt;</span>  
<span class="kw">&lt;/mouse&gt;</span></code></pre></div>
<p>generates the following <a href="#fig:xml-advanced-network-xmlsender-1">output</a>:</p>
<div class="figure">
<img src="pics/xml-advanced-network-xmlsender-1.png" alt="Options allow it to shape the display of the inserted information." id="fig:xml-advanced-network-xmlsender-1" style="width:80.0%" />
<p class="caption"><em>Options allow it to shape the display of the inserted information.</em></p>
</div>
<p>For instance, the option <code>select=0</code> picks the first stream dimension of the stream and adding <code>function=mean</code> replaces a sequence of samples by their mean value.</p>
<p>Options that apply to streams and tuple/map events:</p>
<table>
<colgroup>
<col width="36%" />
<col width="63%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Example</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>select=0</code></td>
<td align="left">Selects the first dimension.</td>
</tr>
<tr class="even">
<td align="left"><code>select=1,3</code></td>
<td align="left">Selects the second and fourth dimension.</td>
</tr>
<tr class="odd">
<td align="left"><code>select=1-3</code></td>
<td align="left">Selects the second, third and fourth dimension.</td>
</tr>
<tr class="even">
<td align="left"><code>select*2=1</code></td>
<td align="left">Selects every second dimension starting from the first dimension.</td>
</tr>
<tr class="odd">
<td align="left"><code>precision=2</code></td>
<td align="left">Displays two decimal places.</td>
</tr>
<tr class="even">
<td align="left"><code>precision=0</code></td>
<td align="left">Omits decimal places.</td>
</tr>
</tbody>
</table>
<p><br />
Options that apply to streams only:</p>
<table>
<colgroup>
<col width="36%" />
<col width="63%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Example</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>function=mean</code></td>
<td align="left">Calculates mean value.</td>
</tr>
<tr class="even">
<td align="left"><code>function=std</code></td>
<td align="left">Calculates standard deviation.</td>
</tr>
<tr class="odd">
<td align="left"><code>function=min</code></td>
<td align="left">Calculates minimum.</td>
</tr>
<tr class="even">
<td align="left"><code>function=max</code></td>
<td align="left">Calculates maximum.</td>
</tr>
<tr class="odd">
<td align="left"><code>function=first</code></td>
<td align="left">Select first sample (latest).</td>
</tr>
<tr class="even">
<td align="left"><code>function=last</code></td>
<td align="left">Select last sample (oldest).</td>
</tr>
</tbody>
</table>
<p><br />
Options that apply to events only:</p>
<table>
<colgroup>
<col width="36%" />
<col width="63%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Example</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>field=time</code></td>
<td align="left">Event start time relative to start of pipeline (in milliseconds).</td>
</tr>
<tr class="even">
<td align="left"><code>field=time_system</code></td>
<td align="left">Event start time relative to start of system (in milliseconds).</td>
</tr>
<tr class="odd">
<td align="left"><code>field=time_relative</code></td>
<td align="left">Elapsed time since event was started (relative to current time stamp in milliseconds).</td>
</tr>
<tr class="even">
<td align="left"><code>field=duration</code></td>
<td align="left">Event duration (in milliseconds).</td>
</tr>
<tr class="odd">
<td align="left"><code>field=event</code></td>
<td align="left">Event name.</td>
</tr>
<tr class="even">
<td align="left"><code>field=sender</code></td>
<td align="left">Sender name.</td>
</tr>
<tr class="odd">
<td align="left"><code>field=state</code></td>
<td align="left">Event state (0=completed, 1=continued).</td>
</tr>
<tr class="even">
<td align="left"><code>field=name</code></td>
<td align="left">Event key (map events only).</td>
</tr>
<tr class="odd">
<td align="left"><code>span=1000</code></td>
<td align="left">Remove event after 1000 ms (if no new event arrives).</td>
</tr>
</tbody>
</table>
<p><br />
To share the xml string with an external application, we use <code>SocketEventWriter</code> with option <code>xml=true</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;SocketEventWriter&quot;</span><span class="ot"> port=</span><span class="st">&quot;2222&quot;</span><span class="ot"> type=</span><span class="st">&quot;0&quot;</span><span class="ot"> xml=</span><span class="st">&quot;true&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;listen</span><span class="ot"> address=</span><span class="st">&quot;ssi@xml&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/object&gt;</span></code></pre></div>
<blockquote>
<p>Check out the full <a href="code/xml/network/xmlsender.pipeline">pipeline</a> and the according <a href="code/xml/network/xmlsender.xml">template</a>.</p>
</blockquote>
<h3 id="xml-advanced-options"><span class="header-section-number">4.2.3</span> Options</h3>
<p>So far, we have learned about <a href="#xml-basics-component">options</a> as a way to configure the behaviour of a component before the execution of a pipeline. However, some options also allow it to change the behaviour of a component <em>at</em> run-time. We can read this from the API when an option is marked as <code>FREE</code> (see <a href="#fig:xml-advanced-options-0">here</a>).</p>
<div class="figure">
<img src="pics/xml-advanced-options-0.png" alt="Options marked as FREE can be changed at run-time." id="fig:xml-advanced-options-0" style="width:80.0%" />
<p class="caption"><em>Options marked as <code>FREE</code> can be changed at run-time.</em></p>
</div>
<p>First, we add an instance of <code>Limits</code>, which keeps stream values in a certain range. The range is defined by options <code>min</code> and <code>max</code>, which we initialize with default values:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;transformer</span><span class="ot"> create=</span><span class="st">&quot;Limits:limits&quot;</span><span class="ot"> min=</span><span class="st">&quot;0.0&quot;</span><span class="ot"> max=</span><span class="st">&quot;1.0&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;pos&quot;</span><span class="ot"> frame=</span><span class="st">&quot;0.2s&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> pin=</span><span class="st">&quot;pos-lim&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/transformer&gt;</span></code></pre></div>
<p>Now, we need a way to access the <code>min</code> and <code>max</code> options at run-time. The <code>ControlGid</code> from the <code>control</code> plug-in does exactly that. We set the <code>id</code> of the controller to our limiter (to target multiple components we separate their ids by ',' or use the '*' operator):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;runnable</span><span class="ot"> create=</span><span class="st">&quot;ControlGrid:control&quot;</span><span class="ot"> id=</span><span class="st">&quot;limits&quot;</span><span class="kw">/&gt;</span>    </code></pre></div>
<p>When the pipeline is started editable options are listed and can be changed (press enter to confirm) as shown <a href="#fig:xml-advanced-options-1">here</a>. Note that we used the <code>runnable</code> tag to include the component. We do this because GUI elements have their own thread and this way we make sure it will be started.</p>
<div class="figure">
<img src="pics/xml-advanced-options-1.png" alt="ControlGrid lists options that are editable at run-time." id="fig:xml-advanced-options-1" style="width:80.0%" />
<p class="caption"><em><code>ControlGrid</code> lists options that are editable at run-time.</em></p>
</div>
<p>To target a specific option we can use <code>ControlTextBox</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;runnable</span><span class="ot"> create=</span><span class="st">&quot;ControlTextBox:control&quot;</span><span class="ot"> id=</span><span class="st">&quot;limits&quot;</span><span class="ot"> name=</span><span class="st">&quot;min&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;runnable</span><span class="ot"> create=</span><span class="st">&quot;ControlTextBox:control&quot;</span><span class="ot"> id=</span><span class="st">&quot;limits&quot;</span><span class="ot"> name=</span><span class="st">&quot;max&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>It gives us an individual text box for each option as shown <a href="#fig:xml-advanced-options-2">here</a>:</p>
<div class="figure">
<img src="pics/xml-advanced-options-2.png" alt="ContolTextBox allows it to target specific options." id="fig:xml-advanced-options-2" style="width:80.0%" />
<p class="caption"><em><code>ContolTextBox</code> allows it to target specific options.</em></p>
</div>
<p>Or in case of a floating point option (single value) we can use <code>ControlSlider</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;runnable</span><span class="ot"> create=</span><span class="st">&quot;ControlSlider:control&quot;</span><span class="ot"> id=</span><span class="st">&quot;limits&quot;</span><span class="ot"> name=</span><span class="st">&quot;min&quot;</span><span class="ot"> defval=</span><span class="st">&quot;0.0&quot;</span><span class="ot"> minval=</span><span class="st">&quot;0.0&quot;</span><span class="ot"> maxval=</span><span class="st">&quot;0.5&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;runnable</span><span class="ot"> create=</span><span class="st">&quot;ControlSlider:control&quot;</span><span class="ot"> id=</span><span class="st">&quot;limits&quot;</span><span class="ot"> name=</span><span class="st">&quot;max&quot;</span><span class="ot"> defval=</span><span class="st">&quot;0.5&quot;</span><span class="ot"> minval=</span><span class="st">&quot;0.5&quot;</span><span class="ot"> maxval=</span><span class="st">&quot;1.0&quot;</span><span class="kw">/&gt;</span></code></pre></div>
<p>It creates a slider for each option as shown <a href="#fig:xml-advanced-options-3">here</a>:</p>
<div class="figure">
<img src="pics/xml-advanced-options-3.png" alt="ControlSlider adds a slider to floating point options." id="fig:xml-advanced-options-3" style="width:80.0%" />
<p class="caption"><em><code>ControlSlider</code> adds a slider to floating point options.</em></p>
</div>
<blockquote>
<p>Check out the full code: <a href="code/xml/options/controller.pipeline">controller</a>, <a href="code/xml/options/textbox.pipeline">textbox</a>, <a href="code/xml/options/slider.pipeline">slider</a>.</p>
</blockquote>
<h1 id="python"><span class="header-section-number">5</span> Python</h1>
<p>SSI allows it to develop new components with <a href="https://www.Python.org/">Python</a>. If the aim is to write extensions to SSI without having to use Visual Studio or some other C++ developing environment Python is a good choice. In this chapter we will learn how to write and use Python components in SSI.</p>
<h2 id="python-components"><span class="header-section-number">5.1</span> Components</h2>
<p>In SSI a Python component is basically a collection of functions, which are called in a certain order. When SSI reads in a Python script it looks which of the relevant functions are available (some functions are optional, while others are mandatory). For instance, the function <code>getSampleDimensionOut(...)</code> will be called to determine the number of dimensions in an output stream. The name of the functions and the number of parameters are fixed. A misspelled function is simply not recognized, whereas an incorrect number of parameters causes an error at run-time. To use a Python script in a (XML) pipeline a wrapper component is interposed, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;PythonConsumer&quot;</span><span class="ot"> script=</span><span class="st">&quot;ssi_print&quot;</span><span class="ot"> syspath=</span><span class="st">&quot;.;my/scripts&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> frame=</span><span class="st">&quot;1.0s&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>will call functions from the script <code>ssi_print.py</code>. The attribute <code>syspath</code> is used to add directories to the system path of Python (by default set to the working directory). In the following we will see each <a href="#basics-component">component</a> (sensor, transformer, ...) has a specific wrapper and uses a different set of functions.</p>
<p>The general syntax of a function in Python is:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> function_name([param1, param2, ...]):  </code></pre></div>
<p>As a dynamic type language the type of a parameter in Python (like every object) is not specified at compile time. Yet, it is important to have in mind which type an object has since this determines the context in which it can be used. For instance, we can call the method <code>count()</code> on a <code>tuple</code> object, but not on a <code>set</code> object. SSI introduces a couple of new <a href="#python-types">types</a> with specific methods and attributes.</p>
<blockquote>
<p>Though, it is possible to use multiple Python components in a single pipeline and even different instances of the same component, one should keep in mind that it is generally not possible to execute Python byte-code from multiple native threads with the consequence that SSI components, even though they run in separate threads, have to get Python's global interpreter lock (GIL) to execute Python code. This means that only one component can actually execute Python code at a time. Hence, using many Python components in a single pipeline may turn into a bottleneck.</p>
</blockquote>
<h2 id="python-types"><span class="header-section-number">5.2</span> Types</h2>
<p>To represent streams in Python a new type <code>ssipystream</code> is introduced. Its accessible fields and methods are:</p>
<ul>
<li><strong>num</strong> [<em>int</em>]: Number of samples</li>
<li><strong>dim</strong> [<em>int</em>]: Number of dimensions</li>
<li><strong>len</strong> [<em>int</em>]: Number of values</li>
<li><strong>tot</strong> [<em>int</em>]: Total number of bytes</li>
<li><strong>byte</strong> [<em>int</em>]: Number of bytes per value</li>
<li><strong>type</strong> [<em>int</em>]: Type code (see below)</li>
<li><strong>sr</strong> [<em>double</em>]: Sample rate in hz</li>
<li><strong>time</strong> [<em>double</em>]: Time stamp in seconds</li>
<li><strong>length()</strong> [return <em>int</em>]: Returns the number of values</li>
<li><strong>shape()</strong> [return (<em>int</em>,<em>int</em>)]: Returns the shape (num x dim)</li>
<li><strong>type()</strong> [return <em>string</em>] Returns the type string identifier (see below)</li>
</ul>
<p>The <code>type</code> field defines the type of a sample values. An enumeration of valid types is defined in <code>ssipystreamtype</code>. Each type also has a code and a string representation:</p>
<table style="width:92%;">
<colgroup>
<col width="8%" />
<col width="16%" />
<col width="11%" />
<col width="9%" />
<col width="45%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Code</th>
<th align="left">Type</th>
<th align="left">String</th>
<th align="left">Bytes</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left"><code>CHAR</code></td>
<td align="left">'b'</td>
<td align="left">1</td>
<td align="left">signed integer (character)</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left"><code>UCHAR</code></td>
<td align="left">'B'</td>
<td align="left">1</td>
<td align="left">unsigned integer (character)</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left"><code>SHORT</code></td>
<td align="left">'h'</td>
<td align="left">2</td>
<td align="left">signed integer (short)</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left"><code>USHORT</code></td>
<td align="left">'H'</td>
<td align="left">2</td>
<td align="left">unsigned integer (short)</td>
</tr>
<tr class="odd">
<td align="left">5</td>
<td align="left"><code>INT</code></td>
<td align="left">'i'</td>
<td align="left">4</td>
<td align="left">signed integer</td>
</tr>
<tr class="even">
<td align="left">6</td>
<td align="left"><code>UINT</code></td>
<td align="left">'I'</td>
<td align="left">4</td>
<td align="left">unsigned integer</td>
</tr>
<tr class="odd">
<td align="left">7</td>
<td align="left"><code>LONG</code></td>
<td align="left">'k'</td>
<td align="left">8</td>
<td align="left">signed integer (long)</td>
</tr>
<tr class="even">
<td align="left">8</td>
<td align="left"><code>ULONG</code></td>
<td align="left">'K'</td>
<td align="left">8</td>
<td align="left">unsigned integer (long)</td>
</tr>
<tr class="odd">
<td align="left">9</td>
<td align="left"><code>FLOAT</code></td>
<td align="left">'f'</td>
<td align="left">4</td>
<td align="left">floating point number (float)</td>
</tr>
<tr class="even">
<td align="left">10</td>
<td align="left"><code>DOUBLE</code></td>
<td align="left">'d'</td>
<td align="left">8</td>
<td align="left">floating point number (double)</td>
</tr>
</tbody>
</table>
<p><br />
To access the n'th value of a stream we write:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">value <span class="op">=</span> stream[n]</code></pre></div>
<p>To access all values one by one we can use an interator:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> s <span class="op">in</span> stream:
    <span class="bu">print</span>(s)</code></pre></div>
<p>To access the m'th dimension value of the n'th samples we write:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">value <span class="op">=</span> stream[n,m]</code></pre></div>
<p>Hence, another way to access every value is:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> n <span class="op">in</span> <span class="bu">range</span>(stream.num):
    <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(stream.dim):     
        <span class="bu">print</span>(stream[n,d])</code></pre></div>
<p>To print a stream we write:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> (stream)</code></pre></div>
<p>To represent an image the type <code>ssipyimage</code> is introduces. Its attributes and methods are:</p>
<ul>
<li><strong>width</strong> [<em>int</em>]: Width in pixels</li>
<li><strong>height</strong> [<em>int</em>]: Height in pixels</li>
<li><strong>channels</strong> [<em>int</em>]: Number of channels per pixel</li>
<li><strong>depth</strong> [<em>int</em>]: Number of bytes per channel</li>
<li><strong>stride</strong> [<em>int</em>]: Stride in bytes (i.e. number of bytes per row)</li>
<li><strong>tot</strong> [<em>int</em>]: Total number of bytes</li>
<li><strong>sr</strong> [<em>double</em>]: Sample rate in hz</li>
<li><strong>time</strong> [<em>double</em>]: Time stamp in seconds</li>
<li><strong>pixel()</strong> [return <em>int</em>]: Returns the number of pixels</li>
<li><strong>size()</strong> [return <em>int</em>]: Returns the number of pixel values</li>
<li><strong>shape()</strong> [return (<em>int</em>,<em>int</em>,<em>int</em>)] Returns the shape of the image (height x width x channels)</li>
</ul>
<p>To describe just the image format the type <code>ssiptyimageparams</code> is available:</p>
<ul>
<li><strong>width</strong> [<em>int</em>]: Width in pixels</li>
<li><strong>height</strong> [<em>int</em>]: Height in pixels</li>
<li><strong>channels</strong> [<em>int</em>]: Number of channels per pixel</li>
<li><strong>depth</strong> [<em>int</em>]: Number of bytes per channel</li>
</ul>
<p>Other than streams it is not possible to access single pixel values. However, both - streams and images - can be converted into NumPy matrices/arrays (requires <a href="http://www.numpy.org/numpy">numpy</a>, see <a href="#installation">installation</a>):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">npmat <span class="op">=</span> numpy.asmatrix(stream) 
npimg <span class="op">=</span> numpy.asarray(image)</code></pre></div>
<p>Since NumPy offers an assortment of routines for fast scientific computing it should be the preferred way to work with streams/images. Both, <code>asmatrix()</code> and <code>asarray()</code>, borrow the memory and hence allow it to work directly on memory allocated by SSI.</p>
<p>The remaining types are (will be explained at the appropriate place):</p>
<p><code>ssipyinfo</code>:</p>
<ul>
<li><strong>time</strong> [<em>double</em>]: Time in seconds</li>
<li><strong>dur</strong> [<em>double</em>]: Duration in seconds</li>
<li><strong>frame</strong> [<em>int</em>]: Number of new frames</li>
<li><strong>delta</strong> [<em>int</em>]: Number of overlapping frames</li>
</ul>
<p><code>ssipychannel</code>:</p>
<ul>
<li><strong>dim</strong> [<em>int</em>]: Number of dimensions</li>
<li><strong>byte</strong> [<em>int</em>]: Number of bytes per value</li>
<li><strong>type</strong> [<em>int</em>]: Type code</li>
<li><strong>sr</strong> [<em>double</em>]: Sample rate in hz</li>
</ul>
<p><code>ssipyevent</code>:</p>
<ul>
<li><strong>time</strong> [<em>int</em>]: Time in milliseconds</li>
<li><strong>dur</strong> [<em>int</em>]: Duration in milliseconds</li>
<li><strong>address</strong> [<em>string</em>]: Address <script type="text/javascript">
<!--
h='&#x73;&#x65;&#110;&#100;&#x65;&#114;';a='&#64;';n='&#x65;&#118;&#x65;&#110;&#116;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x65;&#118;&#x65;&#110;&#116;&#32;&#x61;&#116;&#32;&#x73;&#x65;&#110;&#100;&#x65;&#114;</noscript></li>
<li><strong>state</strong> [<em>int</em>]: Event state (0=completed, 1=continued)</li>
<li><strong>glue</strong> [<em>int</em>]: Glue id (to mark events that belong to each other)</li>
<li><strong>prob</strong> [<em>int</em>]: Confidence value</li>
<li><strong>data</strong> [<em>object</em>]: Data object (e.g. a list or a dictionary)</li>
</ul>
<p><code>ssipyeventboard</code>:</p>
<ul>
<li><strong>COMPLETED</strong> [<em>int</em>]: 0</li>
<li><strong>CONTINUED</strong> [<em>int</em>]: 1</li>
<li><strong>update()</strong> [arguments: time:<em>int</em>, duration:<em>int</em>, address:<em>string</em>, data:<em>object</em>]: Sends an event</li>
</ul>
<h2 id="python-options"><span class="header-section-number">5.3</span> Options and Variables</h2>
<p>A Python component can define options and variables. As discussed <a href="#xml-basics-component">earlier</a> options give us the possibility to tune a component, whereas variables are used to store data between successive function calls. To initialize options and variables we include a function <code>getOptions()</code> to our Python script:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> getOptions(opts, <span class="bu">vars</span>):

    opts[<span class="st">&#39;path&#39;</span>] <span class="op">=</span> <span class="st">&#39;foo.abc&#39;</span>
    opts[<span class="st">&#39;pi&#39;</span>] <span class="op">=</span> <span class="fl">3.142</span>
    
    <span class="bu">vars</span>[<span class="st">&#39;x&#39;</span>] <span class="op">=</span> <span class="dv">0</span>
    <span class="bu">vars</span>[<span class="st">&#39;arr&#39;</span>] <span class="op">=</span> (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)</code></pre></div>
<p>If it exists <code>getOptions()</code> is the first function that is called (even if it not the first function defined in the script - the order of the functions is not relevant). Two dictionaries <code>opts</code> and <code>vars</code> (though their names can be different) are passed as arguments. In Python a dictionary is an associative array (also known as hashes), which elements are accessed via keys. In the following the two dictionaries will be passed to each function and allow it to save information between function calls. However, here we have the possibility to initialize them in the first place.</p>
<p>While variables are only meant for internal use, options can be accessed and overwritten from outside (e.g. in the XML pipeline). Therefore the wrapper provides an option <code>optsstr</code>, which can be used to assign existing options with new values (note that it is not possible to introduce new options that way). For instance, we can assign <code>optsstr=&quot;path=my.abc;pi=3.14159&quot;</code> to override the default values of the options given above. Alternatively, we can provide a file through the option <code>optsfile</code>:</p>
<pre><code>path = foo.abc
pi = 3.14159</code></pre>
<p>However, options defined in <code>optsstr</code> will still overwrite options given by file.</p>
<h2 id="python-sensor"><span class="header-section-number">5.4</span> Sensor</h2>
<p>We want to create a <a href="#basics-pipelines-components">sensor</a> that generates sine and saw waves. Sample rate and dimension of the streams can be set by the user, so we implement <code>getOptions()</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> getOptions(opts, <span class="bu">vars</span>):
    opts[<span class="st">&#39;sr&#39;</span>] <span class="op">=</span> <span class="fl">10.0</span>
    opts[<span class="st">&#39;dim&#39;</span>] <span class="op">=</span> <span class="dv">1</span></code></pre></div>
<p>Next, we implement <code>getChannelNames()</code> to define the channels names:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> getChannelNames(opts, <span class="bu">vars</span>):
    <span class="cf">return</span> {<span class="st">&#39;saw&#39;</span>:<span class="st">&#39;a saw wave&#39;</span>, 
            <span class="co">&#39;sine&#39;</span>:<span class="st">&#39;a sine wave&#39;</span>}</code></pre></div>
<p>The function returns a dictionary with pairs of strings. Each pair defines a channel name (key) and adds a description (value). Now, we need to describe the channel streams, which we do by adding a function <code>initChannel()</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> initChannel(name, channel, types, opts, <span class="bu">vars</span>):
    <span class="cf">if</span> name <span class="op">==</span> <span class="st">&#39;saw&#39;</span>:
        channel.dim <span class="op">=</span>  opts[<span class="st">&#39;dim&#39;</span>]
        channel.<span class="bu">type</span> <span class="op">=</span> types.FLOAT
        channel.sr <span class="op">=</span> opts[<span class="st">&#39;sr&#39;</span>]
    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&#39;sine&#39;</span>:
        channel.dim <span class="op">=</span> opts[<span class="st">&#39;dim&#39;</span>]
        channel.<span class="bu">type</span> <span class="op">=</span> types.FLOAT
        channel.sr <span class="op">=</span> opts[<span class="st">&#39;sr&#39;</span>]
    <span class="cf">else</span>:
        <span class="bu">print</span>(<span class="st">&#39;unkown channel name&#39;</span>)</code></pre></div>
<p>Here, we use the options defined earlier to set the sample rate and the number dimension. As type we choose <code>FLOAT</code> (the number of bytes per value are automatically set depending on the type).</p>
<p>Next, a function named <code>connect()</code> is called. It is the appropriate place to do further initialization steps, e.g. to call driver functions on the sensor. Since we do not connect a physical sensor we simply pass on (we could also omit the function):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> <span class="ex">connect</span>(opts, <span class="bu">vars</span>):
    <span class="cf">pass</span></code></pre></div>
<p>Now, SSI will continuously call the <code>read()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> read(name, sout, reset, board, opts, <span class="bu">vars</span>):    

    time <span class="op">=</span> sout.time
    delta <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> sout.sr

    <span class="cf">if</span> name <span class="op">==</span> <span class="st">&#39;saw&#39;</span>:
        <span class="cf">for</span> n <span class="op">in</span> <span class="bu">range</span>(sout.num):
            <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(sout.dim):
                sout[n,d] <span class="op">=</span> time <span class="op">-</span> math.floor(time)
            time <span class="op">+=</span> delta

    <span class="cf">elif</span> name <span class="op">==</span> <span class="st">&#39;sine&#39;</span>:
        <span class="cf">for</span> n <span class="op">in</span> <span class="bu">range</span>(sout.num):
            <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(sout.dim):
                sout[n,d] <span class="op">=</span> math.sin(<span class="dv">2</span><span class="op">*</span>math.pi<span class="op">*</span>time)
            time <span class="op">+=</span> delta

    <span class="cf">else</span>:
        <span class="bu">print</span>(<span class="st">&#39;unkown channel name&#39;</span>)</code></pre></div>
<p>The first two arguments are the channel name and the output stream, which is pre-allocated and to be filled by the function. The third argument <code>reset</code> will be 1 as long as the pipeline has not been started and 0 afterwards. For instance, if we read from a file we should re-send the first chunk as long as <code>reset</code> is 1. Since we use the current time stamp (elapsed time since pipeline was started) we do not have to consider the flag. To generate the sine/saw values we use two nested <code>for</code> loops. The outer loop iterate over all samples in the stream and increments the time stamp by the duration of a single sample (1 divided by the sample rate). The inner loop iterates over the number of dimensions and assigns the current sample values to each dimension. The function has three more arguments: The first is <code>board</code> and allows it to send events to SSI, which will be explained <a href="#python-events">later</a>. The last two arguments are the dictionaries containing options and variables as discussed <a href="#python-options">before</a>.</p>
<p>Finally, the function <code>disconnect()</code> is called after the pipeline was stopped and allows it to do some clean up. Again, we simply pass on (or omit):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> disconnect(opts, <span class="bu">vars</span>):
    <span class="cf">pass</span></code></pre></div>
<p>To use an instance of our sensor in an <a href="#xml-basics">XML pipeline</a> we use the <a href="#xml-basics-sensor">sensor</a> tag:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;sensor</span><span class="ot"> create=</span><span class="st">&quot;PythonSensor&quot;</span><span class="ot"> script=</span><span class="st">&quot;sensor&quot;</span><span class="ot"> block=</span><span class="st">&quot;0.1&quot;</span><span class="ot"> optsstr=</span><span class="st">&quot;sr=50.0;dim=2&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;sine&quot;</span><span class="ot"> pin=</span><span class="st">&quot;sine&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;saw&quot;</span><span class="ot"> pin=</span><span class="st">&quot;saw&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/sensor&gt;</span></code></pre></div>
<p>We use the option <code>optsstr</code> to overwrite the default values for the sample rate and the number of dimensions. And we set the option <code>block</code> to 0.1 seconds, which defines the interval in which <code>read()</code> will be called.</p>
<blockquote>
<p>Check out the Python <a href="code/python/sensor.py">script</a> and the according <a href="code/python/sensor.pipeline">pipeline</a>.</p>
</blockquote>
<h2 id="python-consumer"><span class="header-section-number">5.5</span> Consumer</h2>
<p>To implement a <a href="#basics-pipelines-components">consumer</a> we add a function <code>consume()</code>, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> consume(info, sin, board, opts, <span class="bu">vars</span>): 
    <span class="cf">for</span> s <span class="op">in</span> sin:
        <span class="bu">print</span>(sin[<span class="dv">0</span>])</code></pre></div>
<p>Since a consumer may receive multiple streams we receive a <code>tuple</code> of streams. In Python a <code>tuple</code> represents a an immutable sequence of objects. This is appropriate since the number of streams will not change between successive calls.</p>
<p>When <code>consume()</code> is called for the first time it will already deliver the first chunks of data. However, sometimes we would like to know how many streams and what kind of streams we will receive (e.g. to initialize temporal variables). To this end, we can add a function <code>consume_enter()</code>, which is called once before the actual processing starts. Likewise, the function <code>consume_flush()</code> is called when the processing was stopped (e.g. to clean up). The following example uses the <code>consume_enter</code> and <code>consume_flush</code> to create and close a file. Note how the file pointer is stored in the variable dictionary.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> consume_enter(sin, board, opts, <span class="bu">vars</span>):
    <span class="bu">vars</span>[<span class="st">&#39;fp&#39;</span>] <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;output.txt&#39;</span>, <span class="st">&#39;w&#39;</span>)
    
<span class="kw">def</span> consume(info, sin, board, opts, <span class="bu">vars</span>): 
    <span class="cf">for</span> s <span class="op">in</span> sin:
        <span class="bu">vars</span>[<span class="st">&#39;fp&#39;</span>].write(<span class="bu">str</span>(s) <span class="op">+</span> <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)

<span class="kw">def</span> consume_flush(sin, board, opts, <span class="bu">vars</span>):
    <span class="bu">vars</span>[<span class="st">&#39;fp&#39;</span>].close()</code></pre></div>
<blockquote>
<p>Check out the Python <a href="code/python/consumer.py">script</a> and the according <a href="code/python/consumer.pipeline">pipeline</a>.</p>
</blockquote>
<h2 id="python-transformer"><span class="header-section-number">5.6</span> Transformer</h2>
<p>To determine the properties of the output stream of a <a href="#basics-pipelines-components">transformer</a> several functions are called, each receiving the according property of the input stream as argument. The functions are:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> getSampleNumberOut(num, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> num

<span class="kw">def</span> getSampleDimensionOut(dim, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> dim

<span class="kw">def</span> getSampleBytesOut(<span class="bu">bytes</span>, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> <span class="bu">bytes</span>

<span class="kw">def</span> getSampleTypeOut(<span class="bu">type</span>, types, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> <span class="bu">type</span></code></pre></div>
<p>Since by default a function returns the property of the input stream, we only have to add functions for properties that actually change. For instance, if a transformer reduces the sample rate by half, we would write:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> getSampleNumberOut(num, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> math.floor(num <span class="op">/</span> <span class="dv">2</span>)</code></pre></div>
<p>Or to change the type from <code>INT</code> to <code>FLOAT</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> getSampleTypeOut(<span class="bu">type</span>, types, opts, <span class="bu">vars</span>):
    <span class="cf">if</span> <span class="bu">type</span> <span class="op">!=</span> types.INT
        <span class="bu">print</span>(<span class="st">&#39;unexpected input type&#39;</span>)
        <span class="cf">return</span> types.UNDEF
    <span class="cf">return</span> types.FLOAT
    
<span class="kw">def</span> getSampleBytesOut(<span class="bu">bytes</span>, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> <span class="dv">4</span></code></pre></div>
<p>As an example we will implement a filter and a feature <a href="#basics-pipelines-components">component</a>. To recap, a filter is a special kind of transformer that does not change the sample rate, whereas a feature reduces the input stream to a single sample.</p>
<h3 id="python-transformer-filter"><span class="header-section-number">5.6.1</span> Filter</h3>
<p>The filter we want to implement sums up the values in all dimensions. Therefore we let the function <code>getSampleDimension()</code> return 1:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> getSampleDimensionOut(dim, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> <span class="dv">1</span>    </code></pre></div>
<p>When the pipeline is started, the function <code>transform()</code> is continuously called:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> transform(info, sin, sout, sxtra, board, opts, <span class="bu">vars</span>):   
    <span class="cf">for</span> n <span class="op">in</span> <span class="bu">range</span>(sin.num):
        sout[n] <span class="op">=</span> <span class="dv">0</span>
        <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(sin.dim):
            sout[n] <span class="op">+=</span> sin[n,d]</code></pre></div>
<p>The first argument is a variable of type <code>ssitypeinfo</code> (see <a href="#python-types">here</a>) including the current time stamp and duration in seconds, as well as, the number of frame and delta samples. The next two arguments are the input stream and the pre-allocated output stream. Additional streams are passed in a tuple <code>sxtra</code> followed by event board, options and variables. We use the outer loop to iterate over all samples and initialize the output sample with 0. The inner loop iterates over the dimensions and sums up the sample values.</p>
<p>With NumPy we can rewrite above statement as follows:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> transform(info, sin, sout, sxtra, board, opts, <span class="bu">vars</span>):
    npin <span class="op">=</span> numpy.asmatrix(sin)
    npout <span class="op">=</span> numpy.asmatrix(sout)
    numpy.<span class="bu">sum</span>(npin, axis<span class="op">=</span><span class="dv">1</span>, out<span class="op">=</span>npout)</code></pre></div>
<p>Since NumPy is optimized to work with multi-dimensional arrays it can run almost as quickly as equivalent C code. Note that we use the argument <code>out</code> to prevent that a new array is created. Instead the result is directly written into the output stream.</p>
<blockquote>
<p>Check out the Python <a href="code/python/filter.py">script</a> (NumPy <a href="code/python/filter_np.py">version</a>) and the according <a href="code/python/filter.pipeline">pipeline</a>.</p>
</blockquote>
<h3 id="python-transformer-feature"><span class="header-section-number">5.6.2</span> Feature</h3>
<p>The feature we want to implement returns the energy in each dimension. Since this does not change the number of dimensions we do not need to implement <code>getSampleDimensionOut()</code>. In fact, for our purpose it is sufficient to implement <code>transform()</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> transform(info, sin, sout, sxtra, board, opts, <span class="bu">vars</span>):   
    <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(sin.dim):
        sout[d] <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> n <span class="op">in</span> <span class="bu">range</span>(sin.num):
        <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(sin.dim):
            val <span class="op">=</span> sin[n,d]
            sout[d] <span class="op">+=</span> val<span class="op">*</span>val
    <span class="cf">for</span> d <span class="op">in</span> <span class="bu">range</span>(sin.dim):
        sout[d] <span class="op">=</span> math.sqrt(sout[d] <span class="op">/</span> sin.num)  </code></pre></div>
<p>The first loop initializes the output stream with zeros. Then we square the elements in the input stream and sum up samples per dimension. Finally, we take the square root on the output stream.</p>
<p>Again, we can rewrite the code with NumPy to get a more compact (and more efficient) version:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> transform(info, sin, sout, sxtra, board, opts, <span class="bu">vars</span>):
    npin <span class="op">=</span> numpy.asmatrix(sin)
    npout <span class="op">=</span> numpy.asmatrix(sout)
    numpy.<span class="bu">sum</span>(npin, axis<span class="op">=</span><span class="dv">0</span>, out<span class="op">=</span>npout)
    numpy.square(npout, out<span class="op">=</span>npout)
    numpy.sqrt(npout, out<span class="op">=</span>npout)</code></pre></div>
<blockquote>
<p>Check out the Python <a href="code/python/feature.py">script</a> (NumPy <a href="code/python/feature_np.py">version</a>) and the according <a href="code/python/feature.pipeline">pipeline</a>.</p>
</blockquote>
<h2 id="python-events"><span class="header-section-number">5.7</span> Events</h2>
<p>If we want to send <a href="#basics-pipelines-events">events</a> from a Python component we should implement the function <code>getEventAddress()</code>. It tells SSI the address(es) we are going to use:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> getEventAddress(opts, <span class="bu">vars</span>):
    <span class="cf">return</span> <span class="st">&#39;empty,string,tuple,map@python&#39;</span></code></pre></div>
<p>The variable <code>eboard</code>, which has the <a href="#python-types">type</a> <code>ssipyeventboard</code>, provides a function <code>update()</code>, which we call to send an event. It takes the start time and duration (in milliseconds), the event address and possibly an object to provide optional data. As explained <a href="#xml-basics-events">earlier</a> SSI supports four types of events: <code>EMPTY</code>, <code>STRING</code>, <code>TUPLE</code> and <code>MAP</code>. The event type is automatically determined from the provided data:</p>
<table style="width:40%;">
<colgroup>
<col width="16%" />
<col width="23%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Data</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>EMPTY</code></td>
<td align="left">None</td>
</tr>
<tr class="even">
<td align="left"><code>STRING</code></td>
<td align="left">String</td>
</tr>
<tr class="odd">
<td align="left"><code>TUPLE</code></td>
<td align="left">Float/Tuple/List</td>
</tr>
<tr class="even">
<td align="left"><code>MAP</code></td>
<td align="left">Dictionary</td>
</tr>
</tbody>
</table>
<p><br />
The following example shows all four versions. Note that we use a <code>OrderedDict</code> instead of a regular dictionary to make sure the keys are kept in the given order:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> send_enter(opts, <span class="bu">vars</span>):
    <span class="cf">pass</span>

<span class="kw">def</span> consume(info, sin, board, opts, <span class="bu">vars</span>): 

    npin <span class="op">=</span> numpy.asmatrix(sin[<span class="dv">0</span>])
    mean <span class="op">=</span> numpy.mean(npin, axis<span class="op">=</span><span class="dv">0</span>)

    time_ms <span class="op">=</span> <span class="bu">round</span>(<span class="dv">1000</span> <span class="op">*</span> info.time)
    dur_ms <span class="op">=</span> <span class="bu">round</span>(<span class="dv">1000</span> <span class="op">*</span> info.dur)
    
    board.update(time_ms, dur_ms, <span class="st">&#39;empty@python&#39;</span>, state<span class="op">=</span>board.COMPLETED)
    board.update(time_ms, dur_ms, <span class="st">&#39;string@python&#39;</span>, <span class="bu">str</span>(mean))<span class="op">;</span>
    board.update(time_ms, dur_ms, <span class="st">&#39;tuple@python&#39;</span>, (mean[<span class="dv">0</span>,<span class="dv">0</span>], mean[<span class="dv">0</span>,<span class="dv">1</span>]))<span class="op">;</span>
    board.update(time_ms, dur_ms, <span class="st">&#39;map@python&#39;</span>, OrderedDict([(<span class="st">&#39;x&#39;</span>,mean[<span class="dv">0</span>,<span class="dv">0</span>]), (<span class="st">&#39;y&#39;</span>,mean[<span class="dv">0</span>,<span class="dv">1</span>])]))<span class="op">;</span>
    
<span class="kw">def</span> send_flush(opts, <span class="bu">vars</span>):
    <span class="cf">pass</span></code></pre></div>
<p>By default the events are sent as completed events. We can manually set the state by setting the argument <code>state</code>. Addionally, there are arguments <code>glue</code> and <code>prob</code> to overwrite the glue identifier and the confidence value. The functions <code>send_enter()</code> and <code>send_flush()</code> will be called once before the pipeline is started and after the pipeline was stopped. Note that we have to convert the time stamps provided in the <code>info</code> struct from seconds to milliseconds.</p>
<p>In the XML pipeline we use a <code>PythonConsumer</code> to connect the script with a input stream:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;PythonConsumer&quot;</span><span class="ot"> script=</span><span class="st">&quot;events&quot;</span><span class="ot"> syspath=</span><span class="st">&quot;.&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> address=</span><span class="st">&quot;click@mouse&quot;</span><span class="kw">/&gt;</span>         
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>Of course, we can also receive events. Therefore we implement the function <code>update()</code> (<code>listen_enter()</code> and <code>listen_flush()</code> are again optional):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> listen_enter(opts, <span class="bu">vars</span>):
    <span class="cf">pass</span>

<span class="kw">def</span> update(event, board, opts, <span class="bu">vars</span>):    
    <span class="bu">print</span>(<span class="st">&#39;time    = </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>event.time)
    <span class="bu">print</span>(<span class="st">&#39;dur     = </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>event.dur)
    <span class="bu">print</span>(<span class="st">&#39;address = </span><span class="sc">%s</span><span class="st">&#39;</span> <span class="op">%</span>event.address)    
    <span class="bu">print</span>(<span class="st">&#39;state   = </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>event.state)
    <span class="bu">print</span>(<span class="st">&#39;glue    = </span><span class="sc">%d</span><span class="st">&#39;</span> <span class="op">%</span>event.glue)    
    <span class="bu">print</span>(<span class="st">&#39;data    = </span><span class="sc">%s</span><span class="st">&#39;</span> <span class="op">%</span><span class="bu">str</span>(event.data))

<span class="kw">def</span> listen_flush(opts, <span class="bu">vars</span>):
    <span class="cf">pass</span></code></pre></div>
<p>In the XML pipeline we embed the script in a <code>PythonObject</code> and add the <code>&lt;listen/&gt;</code> tag to specify which events we would like to receive:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;object</span><span class="ot"> create=</span><span class="st">&quot;PythonObject&quot;</span><span class="ot"> script=</span><span class="st">&quot;events&quot;</span><span class="ot"> syspath=</span><span class="st">&quot;.&quot;</span><span class="kw">&gt;</span>      
    <span class="kw">&lt;listen</span><span class="ot"> address=</span><span class="st">&quot;@python&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/object&gt;</span>   </code></pre></div>
<p>Note that we use a single script <code>events.py</code> for sending and receiving the events. Since a consumer can also receive events, we can also merge the two statements:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;PythonConsumer&quot;</span><span class="ot"> script=</span><span class="st">&quot;events&quot;</span><span class="ot"> syspath=</span><span class="st">&quot;.&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;cursor&quot;</span><span class="ot"> address=</span><span class="st">&quot;click@mouse&quot;</span><span class="kw">/&gt;</span>         
    <span class="kw">&lt;listen</span><span class="ot"> address=</span><span class="st">&quot;@python&quot;</span><span class="kw">/&gt;</span> 
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>The result is shown <a href="#fig:python-events-0">here</a>.</p>
<div class="figure">
<img src="pics/python-events-0.png" alt="Sending events from a component written in Python." id="fig:python-events-0" style="width:80.0%" />
<p class="caption"><em>Sending events from a component written in Python.</em></p>
</div>
<blockquote>
<p>Check out the Python <a href="code/python/events.py">script</a> and the according <a href="code/python/events.pipeline">pipeline</a>.</p>
</blockquote>
<h2 id="image-processing"><span class="header-section-number">5.8</span> Image Processing</h2>
<p>In SSI an image is seen as a single block of bytes (i.e. a video is a stream with a single dimension). However, naturally we want to represent an image as a three dimensional array defined by the number of horizontal pixels (columns or width), the number of vertical pixels (rows or height) and the number of channels. Therefore, the type <a href="#python-types"><code>ssipyimage</code></a> has been introduced along with a set of special wrappers, which ensure that the samples of an input stream are converted to images. Again, the best way to work with images is by converting them to a NumPy array:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">img <span class="op">=</span> numpy.asarray(stream)</code></pre></div>
<p>Once converted into a NumPy array, we can do further processing using the popular image processing library <a href="http://opencv.org/">OpenCv</a>. For instance, to flip and display an image we write:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> consume(info, sin, board, opts, <span class="bu">vars</span>): 
    img <span class="op">=</span> numpy.asarray(sin[<span class="dv">0</span>])
    cv2.flip(img, <span class="dv">0</span>, img)
    cv2.imshow(<span class="st">&#39;mywindow&#39;</span>, img)
    cv2.resizeWindow(<span class="st">&#39;mywindow&#39;</span>, sin[<span class="dv">0</span>].width, sin[<span class="dv">0</span>].height)
    cv2.waitKey(<span class="dv">1</span>)</code></pre></div>
<p>To know the properties of the image stream before <code>consume()</code> is called for the first time, we implement the function <code>setImageFormatIn()</code>, which receives a variable of type <a href="#python-types"><code>ssipyimageparams</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setImageFormatIn(<span class="bu">format</span>, opts, <span class="bu">vars</span>): 
    <span class="bu">print</span>(<span class="bu">format</span>)    </code></pre></div>
<p>To use the script in a pipeline we first need an image source. The <code>camera</code> plug-in includes a sensor to connect video devices:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;sensor</span><span class="ot"> create=</span><span class="st">&quot;Camera&quot;</span><span class="ot"> option=</span><span class="st">&quot;camera&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> channel=</span><span class="st">&quot;video&quot;</span><span class="ot"> pin=</span><span class="st">&quot;video&quot;</span><span class="ot"> size=</span><span class="st">&quot;2.0s&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/sensor&gt;</span></code></pre></div>
<p>We can now connect the output of the camera to our script using <code>PythonImageConsumer</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;consumer</span><span class="ot"> create=</span><span class="st">&quot;PythonImageConsumer&quot;</span><span class="ot"> script=</span><span class="st">&quot;ssi_imgplot&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;video&quot;</span><span class="ot"> frame=</span><span class="st">&quot;1&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/consumer&gt;</span></code></pre></div>
<p>In the same way we can manipulate a video stream. For example, to convert the input images into gray-scale we write:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> transform(info, sin, sout, sxtra, board, opts, <span class="bu">vars</span>):   
    iin <span class="op">=</span> numpy.asarray(sin)
    iout <span class="op">=</span> numpy.asarray(sout)
    cv2.cvtColor(iin, cv2.COLOR_RGB2GRAY, iout)</code></pre></div>
<p>However, since the output image is pre-allocated, we need to tell SSI that the dimension of the output image is 1. Therefore, we implement the function <code>getImageFormatOut()</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> getImageFormatOut(<span class="bu">format</span>, opts, <span class="bu">vars</span>): 
    <span class="bu">format</span>.channels <span class="op">=</span> <span class="dv">1</span>
    <span class="cf">return</span> <span class="bu">format</span></code></pre></div>
<p>To use the script in a pipeline we use <code>PythonImageFilter</code>:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;transformer</span><span class="ot"> create=</span><span class="st">&quot;PythonImageFilter&quot;</span><span class="ot"> script=</span><span class="st">&quot;image_filter&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;video&quot;</span><span class="ot"> frame=</span><span class="st">&quot;1&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> pin=</span><span class="st">&quot;gray&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/transformer&gt;</span></code></pre></div>
<p>Finally, we can also extract features from an image and feed them back in the pipeline. For instance, we can calculate the mean value in each channel:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> setImageFormatIn(<span class="bu">format</span>, opts, <span class="bu">vars</span>): 
    <span class="bu">vars</span>[<span class="st">&#39;channels&#39;</span>] <span class="op">=</span> <span class="bu">format</span>.channels

<span class="kw">def</span> getSampleDimensionOut(dim, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> <span class="bu">vars</span>[<span class="st">&#39;channels&#39;</span>]

<span class="kw">def</span> getSampleTypeOut(<span class="bu">type</span>, types, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> types.FLOAT

<span class="kw">def</span> getSampleBytesOut(<span class="bu">bytes</span>, opts, <span class="bu">vars</span>):
    <span class="cf">return</span> <span class="dv">4</span>
    
<span class="kw">def</span> transform(info, sin, sout, sxtra, board, opts, <span class="bu">vars</span>):   
    iin <span class="op">=</span> numpy.asarray(sin)
    iout <span class="op">=</span> numpy.reshape(sout, <span class="bu">vars</span>[<span class="st">&#39;channels&#39;</span>])
    iin.mean((<span class="dv">0</span>,<span class="dv">1</span>),out<span class="op">=</span>iout)</code></pre></div>
<p>Note, that once more we implement <code>setImageFormatIn()</code> to know how many channels we will receive. We need this information to return the correct number of output dimensions. To use the feature in a pipeline we add:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;transformer</span><span class="ot"> create=</span><span class="st">&quot;PythonImageFeature&quot;</span><span class="ot"> script=</span><span class="st">&quot;image_feature&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;input</span><span class="ot"> pin=</span><span class="st">&quot;video&quot;</span><span class="ot"> frame=</span><span class="st">&quot;1&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;output</span><span class="ot"> pin=</span><span class="st">&quot;average&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/transformer&gt;</span></code></pre></div>
<blockquote>
<p>Check out the <a href="code/python/image.pipeline">pipeline</a> and the according scripts: <a href="code/python/image_consumer.py">consumer</a>, <a href="code/python/image_feature.py">feature</a>, and , <a href="code/python/image_filter.py">filter</a>.</p>
</blockquote>
<h1 id="c"><span class="header-section-number">6</span> C++</h1>
<p>For the moment please refer to <a href="tutorial/tutorial.pdf">this</a> document.</p>
            </div>
    </div>
  </div>
  <script src="templates/menu/js/video.js"></script>

</body>
</html>
